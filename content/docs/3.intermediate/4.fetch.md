---
title: Data Fetch
description: API 통신 및 데이터 페칭에 대한 가이드라인을 제공합니다.
navigation: 
  icon: i-lucide-cable
---

## Vue.js 환경에서의 API 통신 기본
Vue.js 애플리케이션에서 백엔드 서버와 데이터를 주고받는 API 통신은 사용자 인터페이스를 동적으로 구성하는 데 필수적입니다. 이를 위해 주로 두 가지 방식인 Fetch API와 Axios 라이브러리가 사용됩니다.

### Fetch API 활용
Fetch API는 웹 브라우저에 내장된 JavaScript API로, 비동기 네트워크 요청을 수행하고 응답을 처리하는 현대적인 방법을 제공합니다. 이는 `XMLHttpRequest`의 한계를 극복하기 위해 설계되었으며, Promise 기반으로 동작하여 사용이 간편하고 코드를 더 깔끔하게 작성할 수 있습니다.
- 기본 사용법: Vue 컴포넌트의 `setup` 함수 내에서 `fetch()` 함수를 사용하여 API 엔드포인트에 GET 요청을 보낼 수 있습니다. 응답은 JSON 형식으로 파싱하고 컴포넌트의 상태를 업데이트하는 데 사용됩니다.
```js
async function fetchData(url) {
  try {
    const response = await fetch(url);

    // 응답이 정상인지 확인 (200~299)
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    // JSON 형식으로 파싱
    const data = await response.json();

    console.log('✅ 데이터:', data);
    return data;

  } catch (error) {
    console.error('❌ 요청 실패:', error);
    return null;
  }
}

// 사용 예시
fetchData('https://api.example.com/data');
```

### Axios 라이브러리 활용
Axios는 Promise 기반 HTTP 클라이언트 라이브러리로, 브라우저와 Node.js 환경 모두에서 사용할 수 있으며 Vue.js에서 API 통신을 위한 권장 라이브러리 중 하나입니다. Axios는 요청 및 응답 인터셉터, 자동 JSON 변환, 요청 취소 및 타임아웃 설정 등 다양한 편리 기능을 제공합니다.

- 설치 및 전역 설정: ​프로젝트에 Axios를 추가하려면 사용하는 패키지 매니저의의 명령어를 사용합니다 (ex: pnpm add axios). 전역에서 쉽게 사용하기 위해 플러그인으로 등록하여 컴포넌트 내에서 접근할 수 있도록 합니다.

- HTTP 메서드 사용: Axios는 GET, POST, PUT, DELETE 등 다양한 HTTP 요청 메서드를 지원합니다.
  - GET 요청: `axios.get('API_URL')`과 같이 사용하며, 쿼리 파라미터를 포함할 수 있습니다.
  - POST 요청: `axios.post('API_URL', data_object)` 형태로 사용하며, 두 번째 인자로 전송할 데이터를 포함합니다.
  - 설정 객체: `headers`, `params`, `baseURL`, `timeout`, `responseType` 등 다양한 옵션을 설정 객체(`config`)로 전달하여 요청을 세밀하게 제어할 수 있습니다.

```ts
// src/api/request.ts
import axios from 'axios';

const request = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  timeout: 10000,
});

// 요청/응답 인터셉터
request.interceptors.request.use(config => {
  // 토큰 추가 등
  return config;
});

request.interceptors.response.use(
  response => response.data,
  error => Promise.reject(error)
);

export default request;
```
```vue
<script setup lang="ts">
import request from '@/api/request';

const users = await request.get('/users');
console.log(users);
</script>
```


## Nuxt.js 환경에서의 데이터 페칭 메커니즘
Nuxt는 Vue.js 기반의 Universal 프레임워크로서, 서버와 클라이언트 양쪽에서 코드를 실행할 수 있습니다. ​이 특성 때문에 Nuxt는 데이터 페칭 시 서버-클라이언트 간의 중복 호출 문제를 방지하고 효율적인 데이터 관리를 위해 $fetch, useAsyncData, useFetch 세 가지 핵심 도구를 제공합니다.

### $fetch
`$fetch`는 Nuxt에서 제공하는 가장 기본적인 네트워크 요청 도구로, ofetch 라이브러리를 기반으로 합니다. ​클라이언트와 서버 양쪽에서 사용할 수 있지만, 상태를 서버에서 클라이언트로 전이하지 않는다는 중요한 특징이 있습니다. ​이로 인해 `setup` 함수 내에서 `await $fetch()`를 직접 사용하면 서버에서 한 번(HTML 렌더링을 위해) 그리고 클라이언트에서 한 번(HTML 하이드레이션 시) 데이터를 두 번 페칭하는 문제가 발생할 수 있습니다.

- 적절한 사용 사례: ​주로 사용자 상호작용(이벤트 기반)에 따라 클라이언트 사이드에서만 API 호출을 보내야 할 때 적합합니다. ​특히 POST, PUT, PATCH, DELETE와 같은 데이터를 변경하는 메서드에 주로 활용됩니다.
```vue
<!-- 클라이언트 사이드 상호작용에 $fetch 사용 예시 -->
<script setup lang="ts">
  const postURL = "https://jsonplaceholder.typicode.com/posts";
  function contactForm() {
    $fetch(`${postURL}`, {
      method: 'POST',
      body: { hello: 'world' }
    }).then(response => {
      console.log('Response:', response);
    }).catch(error => {
      console.error('Error:', error);
    });
  }
</script>

<template>
  <button @click="contactForm">Submit</button>
</template>
```

### useAsyncData
`useAsyncData`는 Nuxt에서 비동기 데이터를 서버 사이드 렌더링(SSR)에 맞춰 손쉽게 처리할 수 있게 해주는 composale 입니다. 이 메서드는 데이터를 서버에서 한 번만 가져오고 그 데이터를 페이로드(payload)를 통해 클라이언트로 전달하여 클라이언트 사이드에서 데이터를 다시 가져오는 불필요한 작업을 줄여줍니다. 이 페이로드는 `useNuxtApp().payload`를 통해 접근 가능합니다.

- 핵심 기능 및 옵션:
  - `key 파라미터`: 데이터 가져오기 요청을 고유하게 식별하는 데 사용됩니다. `key`를 제공하지 않으면 Nuxt는 파일 이름과 인스턴스 라인 번호를 기반으로 고유한 키를 생성합니다.
  - `dedupe` 옵션: 동일한 키를 가진 요청이 중복으로 발생하지 않도록 방지하여 성능을 최적화합니다. 기본값은 `cancel`로, 새 요청 시 기존 요청을 취소하고 새로운 요청을 진행합니다. `defer`로 설정하면 기존 요청이 진행 중일 때 새 요청을 만들지 않고 기존 요청이 완료될 때까지 대기합니다.
  - `refresh`/`execute` 함수: 데이터를 다시 가져오거나 초기화하는 데 사용되며, 캐시 관리와 중복 호출 방지를 담당합니다.
  - 'pending`/`status`: 데이터 요청의 로딩 상태를 나타냅니다.
  - `lazy`: 클라이언트 측 탐색을 차단하지 않고 라우트 로딩 후 비동기 함수를 해결할지 여부를 설정합니다 (기본값: `false`). `true`로 설정하면 초기 로드 속도가 빨라지지만, 데이터가 로드되기 전가지 로딩 상태를 표시해야 합니다.
  - `immediate`: 요청을 즉시 실행할지 여부를 설정합니다 (기본값: `true`). `false`로 설정하면 `refresh` 함수를 명시적으로 호출해야 데이터를 가져옵니다.
  - `default`: 비동기 함수가 해결되기 전에 데이터의 기본값을 설정하는 팩토리 함수입니다. `lazy: true` 또는 `immediate: false` 옵션과 함께 유용하게 사용되어 로딩 중에도 UI 레이아웃 안정성을 유지할 수 있습니다.
  - `transform`: `handler` 함수의 결과를 변환하는데 사용될 수 있는 함수입니다. 데이터를 필요한 형태로 가공하여 컴포넌트에 제공하는 역할을 합니다.
  - `pick`: `handler` 함수의 결과에서 지정된 키만 선택합니다. 불필요한 데이터를 필터링하고 데이터 구조를 간결하게 유지하는 데 유용합니다.
  - `watch`: 반응형 소스를 감시하여 자동으로 데이터를 갱신합니다. 동적 데이터 요청이나 실시간 데이터 갱신에 활용됩니다.
  - `server`: 데이터를 서버에서 가져올지 여부를 설정합니다 (기본값: `true`). `false`로 설정하면 클라이언트 단에서만 API 호출이 발생합니다.
- 적절한 사용 사례: CMS나 서드 파티 서비스가 자체적인 쿼리 레이어를 제공할 때, 또는 여러 `$fetch` 요청을 병렬로 처리하고 그 결과를 하나로 결합하여 반환하고 싶을 때 유용합니다.
```vue
<!-- useAsyncData 기본 사용법 예시 -->
<script setup lang="ts">
  const getURL = "https://jsonplaceholder.typicode.com/todos/1";
  const { data, pending, error, refresh, clear } = await useAsyncData('item', () => $fetch(`${getURL}`));
</script>

<template>
  <div v-if="pending">Loading...</div>
  <div v-else-if="error">Error: {{ error.message }}</div>
  <div v-else>{{ data }}</div>
</template>
```

### useFetch
`useFetch`는 `useAsyncData`와 `$fetch`를 편리하게 감싸주는 메서드입니다. URL과 fetch 옵션을 기반으로 자동으로 키를 생성하고, 서버 라우트 기반 타입 힌트를 제공하며, API 응답 타입을 추론합니다.` useFetch`는 `useAsyncData`와 마찬가지로 `setup` 함수, 플러그인, 라우트 미들웨어에서 직접 호출될 수 있으며, 서버에서 클라이언트로 응답을 Nuxt 페이로드에 추가하여 클라이언트에서 데이터를 다시 패칭하지 않도록 처리합니다.

- useAsyncData와의 차이점: `useFetch`는 기본적으로 URL을 문자열 형태로 직접 전달받는 반면, `useAsyncData`는 콜백 함수를 통해 API를 호출합니다. ​이 차이 때문에 동적으로 변경되는 URL이나 매개변수를 처리하는 방식에 차이가 발생할 수 있습니다. Nuxt 3에서는 `useFetch`에 `query` 옵션을 통해 전달된 객체를 자동으로 문자열화하고 URL에 추가하는 기능이 내장되어 있습니다. ​하지만 `useFetch`도 URL을 콜백 함수 형태로 전달하면 `useAsyncData`처럼 동적으로 URL을 처리할 수 있습니다.
- 인터셉터 지원: `useFetch`는 요청과 응답을 가로채고 추가적인 처리를 할 수 있는 인터셉터(onRequest, onResponse, onError 등)를 사용할 수 있습니다. ​이는 전역적으로 API 코드를 관리하는 데 매우 유용한 기능입니다.

```vue
<!-- useFetch 기본 사용법 예시 -->
<script setup lang="ts">
  const { data, pending, error, refresh, clear } = await useFetch('/api/data');
</script>
```

### 세 메서드의 주요 차이점 비교
| 특징 | $fetch | useAsyncData | useFetch |
|----------|----------|----------|----------|
| 기본 개념 |	​저수준 HTTP 클라이언트 (ofetch 기반) |	SSR/CSR 친화적 비동기 데이터 컴포저블	| `useAsyncData`와 `$fetch`의 래퍼 |
| 지원 환경	| 서버 및 클라이언트 | ​서버 및 클라이언트 |​서버 및 클라이언트 |
| 중복 요청 방지| X (SSR 시 중복 호출 발생)	| O (key, dedupe, Nuxt 페이로드 활용)	| O (useAsyncData 기반, Nuxt 페이로드 활용) |
| 데이터 캐싱 | X (상태 전이 없음) | O (key 기반 내부 캐싱)	| O (useAsyncData 기반 내부 캐싱) |
| 상태 관리	| X (로딩, 에러 등 수동 처리)	| O (data, pending, error, refresh 등 반응형 제공) | O (useAsyncData와 동일) |
| 매개변수 전달 방식 | URL 문자열 + 옵션 객체	| ​비동기 콜백 함수	| URL 문자열 또는 콜백 함수 + 옵션 객체 |
| 동적 매개변수 처리 | 수동 처리 필요	| 콜백 함수 내에서 외부 반응형 값 참조 | ref 자체 전달 시 자동 unref 및 갱신​, 또는 콜백 함수 사용 |
| 타입 지원 | ​최소화됨 | 콜백 함수 내에서 명시적 타입 지정 필요 | URL 기반 자동 타입 추론 및 타입 힌트 제공 |
| 인터셉터 지원 | $fetch.create로 커스터마이징 가능	| 핸들러 함수 내 $fetch 커스터마이징 | O (onRequest, onResponse 등) |
| 주요 사용 목적 | ​클라이언트 측 이벤트 기반 요청 (POST, PUT, DELETE 등)	| SSR 데이터 페칭, 복잡한 비동기 로직, 여러 API 통합, 외부 쿼리 레이어 감싸기 | ​간단한 GET 요청, 간결한 코드, 전역 API 관리 |
| 개발 편의성 | 낮음 (수동 에러/로딩 처리) | 높음 (자동 상태 관리, 유연한 옵션) | 매우 높음 (간결한 문법, 자동 타입 추론, 인터셉터) |

## API 에러 핸들링 및 로딩 상태 관리
Vue 및 Nuxt 애플리케이션에서 API 통신 시 발생할 수 있는 오류를 처리하고 로딩 상태를 효과적으로 관리하는 것은 사용자 경험을 향상시키고 애플리케이션의 안정성을 높이는 데 필수적입니다.

### 에러 핸들링 패턴
- `try-catch` 블록: 비동기 API 호출 시 `try-catch` 블록을 사용하여 예외를 포착하고 처리하는 것이 기본적인 방법입니다.
- Nuxt의 에러 유틸리티: Nuxt는 `createError` 및 `showError`와 같은 내장 유틸리티를 제공하여 서버 및 클라이언트 측에서 일관된 방식으로 오류를 처리할 수 있도록 돕습니다.
- `<NuxtErrorBoundary>` 컴포넌트: 클라이언트 측에서 컴포넌트 오류를 격리하고 사용자 친화적인 메시지를 표시하기 위해 `<NuxtErrorBoundary>` 컴포넌트를 사용할 수 있습니다.
- `error` ref 활용: `useAsyncData` 또는 `useFetch`와 같은 데이터 페칭 컴포저블은 `error` 상태를 `ref` 객체로 반환하므로, 이를 통해 API 호출 중 발생한 오류를 확인할 수 있습니다.
- 중앙 집중식 에러 처리: `useApiError`와 같은 컴포저블을 사용하여 401(인증 실패) 또는 403(권한 없음)과 같은 특정 HTTP 상태 코드에 대한 에러 처리를 중앙화할 수 있습니다.
- 플러그인을 통한 에러 처리: Nuxt 플러그인에서 `onRequestError`, `onResponseError`와 같은 인터셉터를 사용하여 API 요청 및 응답 단계에서 발생한 에러를 전역적으로 처리하고 로컬라이징된 에러 메시지를 제공할 수 있습니다.

### 로딩 상태 관리 패턴
- 상태 변수 활용: `pending` 또는 `loading`과 같은 반응형 불리언(boolean) 변수를 사용하여 API 요청의 시작과 완료 시점에 따라 로딩 상태를 관리합니다.
- UI 로딩 인디케이터: 이 로딩 상태 변수를 활용하여 UI에서 스켈레톤 UI, 로딩 스피너 또는 메시지 등을 조건부로 렌더링함으로써 사용자에게 피드백을 제공합니다.
- Nuxt 컴포저블의 `pending` 상태: `useAsyncData` 및 `useFetch`는 `pending` 상태를 자동으로 관리하며, 이는 UI의 로딩 인디케이터에 직접 연결하여 사용할 수 있습니다.
```vue
<!-- Nuxt useAsyncData를 활용한 로딩 상태 관리 예시 -->
<script setup lang="ts">
  const { data, pending, error } = await useAsyncData('item', () => $fetch('/api/some-data'));
</script>
<template>
  <div v-if="pending">데이터를 불러오는 중입니다...</div>
  <div v-else-if="error">오류 발생: {{ error.message }}</div>
  <div v-else>데이터: {{ data }}</div>
</template>
```

## API 통신 환경 구성 및 보안
Nuxt 환경에서 API 통신을 구성하고 보안을 강화하기 위해서는 `runtimeConfig`, 미들웨어, 플러그인 등을 전략적으로 활용하는 것이 중요합니다.

### `runtimeConfig`를 이용한 설정 관리
Nuxt의 `runtimeConfig` API는 애플리케이션의 구성과 비밀 정보를 관리하는 데 사용됩니다. 환경 변수를 안전하게 주입하고 클라이언트와 서버 환경에서 접근 권한을 분리하여 관리할 수 있습니다.
- `private` 키: `runtimeConfig.apiSecret`과 같이 `runtimeConfig` 객체에 직접 정의된 키는 서버 측에서만 접근 가능하며, 클라이언트에 노출되지 않아야 하는 민감한 정보(예: API 키, 데이터베이스 URI)를 저장하는 데 사용됩니다.
- `public` 키: `runtimeConfig.public.apiBase`와 같이 `runtimeConfig.public` 객체에 정의된 키는 클라이언트와 서버 모두에서 접근 가능하며, API 기본 URL과 같이 클라이언트에 노출되어도 무방한 정보를 저장하는 데 사용됩니다.
- 환경 변수 오버라이드: `.env` 파일에 `NUXT_API_SECRET`와 같이 `NUXT_` 접두사를 붙여 환경 변수를 정의하면, 런타임 시 `runtimeConfig`의 해당 값을 덮어쓸 수 있습니다.

### 미들웨어를 활용한 API 통신 제어
​미들웨어는 Nuxt 3에서 페이지 렌더링 또는 API 요청 처리 전에 요청을 가로채고 처리할 수 있는 함수입니다. ​인증, 로깅, 리디렉션, 권한 관리, 속도 제한 등 다양한 용도로 활용됩니다
- 유형: Nuxt 3에는 전역 미들웨어, 이름 지정 미들웨어, 인라인 미들웨어의 세 가지 유형이 있습니다.
- 인증 및 권한 부여: 라우트 미들웨어(`middleware/auth.ts`)를 사용하여 인증되지 않은 사용자의 특정 페이지 접근을 제한하고 로그인 페이지로 리다이렉션할 수 있습니다.
- 속도 제한: 과도한 API 호출을 방지하기 위해 미들웨러를 통해 API 속도 제한을 구현할 수 있습니다.
- 가벼운 구현: 미들웨어는 페이지 로딩 속도에 영향을 미치므로, 복잡한 로직을 피하고 가볍게 유지하는 것이 좋습니다.

### 플러그인을 통한 API 통신 확장
Nuxt 플러그인은 애플리케이션 전반에 걸쳐 공통 기능이나 서드 파티 라이브러리 통합을 제공하는 데 사용됩니다. API 통신과 관련하여 플러그인은 전역 Axios 인스턴스 설정, API 요청에 인증 토큰 주입, 커스텀 `$fetch` 인스턴스 생성 및 에러 처리 로직 통합 등에 활용될 수 있습니다
- 커스텀 API 클라이언트: `plugins.api.ts`와 같은 파일을 생성하여 `$fetch.create`를 통해 커스텀 API 인스턴스를 설정하고, 모든 요청에 사용자 인증 토큰을 자동으로 첨부하거나 응답 및 에러 처리를 정의할 수 있습니다.

### 보안 베스트 프랙티스
- HTTPS 사용: 항상 HTTPS를 사용하여 API 통신을 암호화하고 데이터 전송을 보호해야 합니다.
- 입력 유효성 검사: 서버 측에서 사용자 입력을 항상 검증하여 XSS(Cross-Site Scripting) 및 SQL 인젝션과 같은 공격을 방지합니다.
- 인증 및 권한 부여: JWT(JSON Web Token) 또는 OAuth 2.0과 같은 메커니즘을 사용하여 API 엔드포인트에 대한 인증 및 권한 부여를 구현합니다.
- 토큰 관리: Access Token은 짧은 만료 시간으로 메모리에 저장하고, Refresh Token은 `httpOnly`, `secure`, `samesite` 옵션이 설정된 쿠키에 저장하여 XSS 및 CSRF 공격에 대한 방어력을 높입니다.
- Axios 인터셉터 활용: Axios 인터셉터를 설정하여 모든 API 요청에 Access Token을 자동으로 포함하고, 토큰 만료 시 Refresh Token을 이용해 재발급 후 요청을 재시도하는 로직을 구현합니다.
- Nuxt Security 모듈: `nuxt-security` 모듈을 사용하여 OWASP 보안 패턴 및 원칙을 따르는 HTTP 헤더 및 미들웨어를 자동으로 구성할 수 있습니다.

## 캐싱 전략 및 성능 최적화 (SWR)
데이터 페칭 시 캐싱 전략과 SWR(Stale-While-Revalidate) 패턴을 적용하는 것은 Nuxt 앱의 성능과 사용자 경험을 크게 향상시킬 수 있습니다.

### Nuxt의 데이터 페칭 컴포저블과 캐싱
`useAsyncData` 및 `useFetch`는 Nuxt의 SSR/CSR 환경에서 효율적인 데이터 페칭을 위해 캐싱 기능을 내장하고 있습니다.
- 고유 키(Key) 사용: `useAsyncData는` 고유한 key 파라미터를 통해 각 데이터 요청을 식별하고 캐싱하여 중복 호출을 방지합니다. `useFetch`의 경우 URL을 기반으로 자동으로 키를 생성합니다.
- `dedupe` 옵션: `useAsyncData는` `dedupe` 옵션을 통해 중복 요청 발생 시 기존 요청을 취소하거나 완료될 때까지 대기하는 전략을 설정할 수 있습니다.
- `keep-alive`: Vue의 keep-alive 디렉티브를 사용하여 컴포넌트가 다시 렌더링될 때 `fetch` 훅 호출을 절약하고, 캐시된 데이터를 활용하여 성능을 개선할 수 있습니다.
- `transform` 옵션: `useFetch`와 `useAsyncData` 모두 transform 옵션을 제공하여 API에서 받아온 데이터를 바로 사용하기보다는 필요한 형태로 변환하여 캐시할 수 있습니다. 이는 데이터 가공 로직을 중앙화하고 효율성을 높입니다.
- `watch` 옵션: `useAsyncData는` `watch` 옵션을 통해 반응형 소스를 감시하여 해당 소스가 변경될 때마다 데이터를 자동으로 업데이트할 수 있습니다. ​이는 동적 데이터 요청 상황에서 유용합니다.

### 성능 최적화 전략
- 지연 로딩 (Lazy Loading): ​이미지, 컴포넌트, 라우트 등 중요하지 않은 리소스를 필요할 때만 로드하여 초기 로딩 시간을 단축합니다. Nuxt의 동적 임포트(`defineAsyncComponent(() => import(...))`)를 활용하거나 `<LazyMyComponent>`와 같은 컴포넌트를 사용하여 구현할 수 있습니다.
- 코드 분할 (Code Splitting): ​애플리케이션 코드를 더 작은 청크로 분할하여 초기 로딩 속도를 향상시킵니다. Nuxt는 자동으로 코드를 분할하며, `import()`를 사용하여 큰 컴포넌트를 분할할 수 있습니다.
- 이미지 최적화: `nuxt/image` 모듈을 사용하여 이미지 크기 조정, 형식 최적화(WebP), 지연 로딩 등을 자동으로 처리하여 LCP(Largest Contentful Paint)를 개선합니다.
- 메모이제이션 (Memoization): `computed` 속성 등을 활용하여 비용이 많이 드는 계산을 메모이제이션하여 불필요한 재렌더링을 방지하고 성능을 최적화합니다.
- 번들 크기 최적화: Webpack Bundle Analyzer와 같은 도구를 사용하여 번들 크기를 분석하고, 사용되지 않는 의존성을 제거하거나 더 작은 대안 라이브러리를 사용하여 JavaScript 페이로드를 줄입니다.
- 프리페치 및 프리커넥트: Nuxt는 뷰포트 내 링크를 자동으로 프리페치하여 다음 페이지로의 이동을 가속화하며, 외부 API 또는 폰트의 경우 `preconnect`를 사용하여 초기 연결 시간을 단축할 수 있습니다.