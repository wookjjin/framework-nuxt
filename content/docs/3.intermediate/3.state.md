---
title: Pinia
description: Pinia를 활용한 상태 관리의 개념과 실제 사용 방법을 학습합니다.
navigation: 
  icon: i-simple-icons-pinia
---

## Pinia 개요 및 등장 배경

### Pinia의 정의 및 목적
Pinia는 Vue 컴포넌트나 페이지 간에 상태를 공유할 수 있도록 해주는 스토어 라이브러리입니다. Composition API에 익숙한 사용자라면 `export const state = reactive({})`를 통해 전역 상태를 공유할 수 있다고 생각할 수 있지만, 이는 단일 페이지 애플리케이션(SPA)에서는 유효하나 서버 사이드 렌더링(SSR) 환경에서는 보안 취약점에 노출될 수 있습니다. Pinia는 이러한 문제를 해결하고, 더 나아가 작은 SPA에서도 테스트 유틸리티, 플러그인, 적절한 TypeScript 지원, SSR 지원, Devtools 통합 등 다양한 이점을 제공하며 상태 관리를 용이하게 합니다. Pinia는 기존 Vuex의 복잡성과 보일러플레이트 문제를 해결하고, Composition API 특성을 살려 개발 생산성과 유지보수성을 높이는 것을 주요 목적으로 합니다.

### Vuex와의 관계 및 Pinia로의 전환 배경
Vuex는 오랫동안 Vue.js의 공식 상태 관리 라이브러리였지만, Vue 3 도입 이후 Pinia가 새롭게 등장하면서 많은 개발자들이 Pinia를 선호하게 되었습니다. Vuex 3.x는 Vue 2용, Vuex 4.x는 Vue 3용이었으나, Pinia는 Vuex 5의 많은 아이디어를 통합하여 간결한 API, Composition API 스타일의 API, 그리고 TypeScript 사용 시 강력한 타입 추론 지원을 제공합니다. Vuex는 상태 변경을 위해 `mutations`를 강제하고 `actions`와 `getters`를 함께 사용하여 코드가 장황해지는 경향이 있었으며, TypeScript 지원을 위해 복잡한 래퍼(wrapper)가 필요했습니다. 반면 Pinia는 `mutations`를 제거하고 `actions`에서 직접 상태 변경을 허용하여 코드를 간소화했습니다. 또한, `modules`의 중첩 구조와 `namespaced modules`개념을 없애고 모든 스토어를 기본적으로 독립적이고 동적으로 관리하도록 하여 모듈화의 복잡성을 줄였습니다. 25년 기준으로 Pinia는 Vue 3의 상태 관리 표준으로 완전히 자리 잡았으며, Vuex는 더 이상 새로운 기능을 추가하지 않는 유지보수 모드에 들어갔습니다. 새로운 Vue 기반 애플리케이션을 만들 때는 Pinia 사용이 적극 권장됩니다.

### 주요 장점
Pinia는 다음과 같은 주요 장점 덕분에 Vue 개발자들 사이에서 빠르게 채택되고 있습니다.

- **간결하고 직관적인 API**: Vuex에 비해 더 간결하고 직관적인 API를 제공하여 코드 작성이 쉽습니다.
- **탁월한 TypeScript 지원**: Pinia는 내장된 TypeScript 지원을 통해 강력한 타입 추론과 자동 완성 기능을 제공하여 타입 안전성을 높이고 개발 경험을 향상시킵니다.
- **Composition API와의 완벽한 통합**: Vue 3의 Composition API 및 `<script setup>` 구문과 완벽하게 호환되어, Vue 개발자에게 친숙한 방식으로 스토어를 정의하고 사용할 수 있습니다.
- **모듈화된 아키텍처**: 각 스토어는 독립적으로 구성되어 있어 조직화와 유지보수가 용이하며, 필요한 스토어만 번들에 포함되는 트리 쉐이킹(tree-shakable)이 가능합니다.
- **Devtools 통합**: Vue Devtools와의 원활한 통합을 통해 상태 추적, 시간 여행 디버깅, 액션 및 변이 타임라인 제공 등 향상된 개발 경험을 제공합니다
- **SSR (서버 사이드 렌더링) 지원**: SSR 환경에서 상태를 안전하게 처리하고 클라이언트 측에서 수화(hydration)하는 기능을 지원합니다.
- **적은 보일러플레이트**: Vuex 대비 `mutations` 개념이 없어 코드량이 적고, 상태를 직접 변경할 수 있어 개발의 복잡성이 줄어듭니다.

## Pinia 핵심 개념 및 구조
Pinia의 상태 관리는 `state`, `getters`, `actions` 세 가지 핵심 요소로 구성된 `store`를 중심으로 이루어집니다. ​이러한 개념은 컴포넌트의 `data`, `computed`, `methods`와 유사하게 생각할 수 있습니다.

### 옵션 스토어
이는 Pinia의 전통적인 스토어 구조로, state, getters, 그리고 actions를 명시적으로 구분하여 작성하는 접근 방식을 의미합니다. 이러한 방식은 각각의 역할을 명확히 구분함으로써 코드를 보다 조직적이고 가독성 있게 구성할 수 있는 장점이 있습니다.

```ts
export const useCounterStore = defineStore('counter', {
  state: () => ({ count: 0, name: 'Eduardo' }),
  getters: {
    doubleCount: (state) => state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})
```

### Setup 스토어
Pinia의 Setup Store는 Vue 3의 setup() 함수 스타일인 Composition API를 그대로 활용할 수 있는 유연한 스토어 정의 방식입니다. 이를 통해 ref, computed, watch, async 함수 등을 마치 setup() 안에서 사용하는 것처럼 자유롭게 활용할 수 있습니다.

```ts
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  const name = ref('Eduardo')
  const doubleCount = computed(() => count.value * 2)
  function increment() {
    count.value++
  }

  return { count, name, doubleCount, increment }
})
```
`ref()`는 `state`, `computed()`는 `getters`, `function()`은 `actions` 가 됩니다. Setup 스토어에서는 Pinia가 상태로 인식할 모든 상태 속성을 반드시 `return`해야 합니다.

::caution
즉, 스토어에서는 상태 속성을 비공개로 설정할 수 없습니다. 상태 속성의 일부를 반환하지 않거나 **읽기 전용으로 설정하면 SSR**, devtools, 기타 플러그인이 제대로 작동하지 않을 가능성이 있습니다.
::

Setup 스토어는 옵션 스토어에 비해 훨씬 더 유연한 기능을 제공합니다. 스토어 내부에서 watcher를 생성할 수 있고, composable을 자유롭게 활용할 수 있는 장점이 있습니다. 다만 SSR을 사용하는 경우 composable을 활용하는 과정이 더 복잡해질 수 있다는 점을 염두에 두는 것이 중요합니다.

또한 Setup 스토어는 라우터나 라우트와 같은 전역적으로 제공된 속성에 의존할 수 있는 특징이 있습니다. 애플리케이션 레벨에서 제공된 모든 속성은 `inject()`를 통해 스토어에서도 접근 가능하며 이는 컴포넌트에서 사용되는 방식과 동일합니다.

::warning
`route`나 `inject`된 속성은 스토어 고유의 속성이 아니기 때문에 반환하지 않는 것이 좋습니다.
::

### 스토어 정의 (defineStore)
Pinia에서 스토어는 `defineStore` 함수를 사용하여 정의합니다. 이 함수는 첫 번째 인수로 애플리케이션 전체에서 스토어 인스턴스를 식별하는 고유한 문자열 ID (스토어 ID)를 받습니다. 두 번째 인수는 스토어의 `state`, `getters`, `actions`를 정의하는 객체(Options API 스타일) 또는 함수(Composition API 스타일)가 될 수 있습니다. 일반적으로 `use` 키워드와 스토어 ID, 그리고 `Store` 키워드의 조합으로 이름을 붙여 `export`하는 방식이 권장됩니다. (예: `useCounterStore`)

### State (상태)
`state`는 스토어에서 정의하는 반응형 데이터로, 애플리케이션의 "진실의 원천(source of truth)"입니다. `Options API` 스타일에서는 팩토리 함수로 작성하여 객체를 반환해야 합니다. 이는 여러 스토어 인스턴스가 생성되더라도 상태가 불필요하게 공유되거나 초기화되는 것을 방지하기 위함입니다. `Composition API` 스타일에서는 `ref()`나 `reactive()`를 사용하여 상태를 정의합니다. 스토어에서 정의된 상태는 컴포넌트에서 `useStore()` 훅을 통해 가져온 스토어 인스턴스에서 직접 접근할 수 있습니다.

### Getters (게터)
`getters`는 상태를 기반으로 계산된 값을 반환하는 읽기 전용 함수로, Vue의 `computed` 속성과 유사하게 작동합니다. 게터 함수의 첫 번째 매개변수러 `state` 객체를 얻을 수 있으며, `this` 키워드를 사용하다면 다른 게터에 접근할 수 있습니다. 다만, `this`를 사용할 경우 화살표 함수 대신 일반 함수를 사용해야 하며, 반환 타입을 명시해야 합니다. 게터는 컴포넌트에서 스토어 인스턴스의 속성처럼 직접 접근하여 사용할 수 있습니다.

### Actions (액션)
`actions`는 상태나 게터를 활용하여 실행할 수 있는 함수로, 컴포넌트의 `methods`와 동일합니다. Vuex와 달리 `mutations` 개념이 제거되어 `actions` 내에서 `this` 키워드를 통해 상태를 직접 변경할 수 있으며, 비동기 처리도 가능합니다. `actions` 내에서 다른 `acitons`를 호출할 수도 있습니다. 컴포넌트에서는 스토어 인스턴스의 메서드처럼 직접 호출하여 상태를 수정할 수 있습니다. `actions`에서는 `this`가 스토어 인스턴스를 가리키므로, 화살표 함수 대신 일반 함수 표현식을 사용하는 것이 권장됩니다.

## Pinia 고급 기능
### TypeScript 지원
Pinia는 TypeScript 기반으로 설계되어 탁월한 타입 추론 기능을 제공합니다. JavaScript 사용자에게도 자동 완성 기능을 제공하며​, Vuex와 달리 복잡한 타입 래퍼를 만들 필요 없이 API 자체가 TS 타입 추론을 최대한 활용하도록 설계되었습니다. ​이는 개발 생산성을 높이고 런타임 오류를 줄여 코드 품질을 향상시키는 데 기여합니다.

### 모듈화 및 스토어 구성
Pinia는 `modules`의 중첩 구조 대신 여러 개의 독립적인 스토어를 생성하는 `modular architecture`를 채택합니다. ​각 스토어는 고유한 ID를 가지며, Vuex의 네임스페이스화된 모듈처럼 독립적으로 작동합니다. ​이를 통해 코드 조직화를 개선하고 복잡한 상태 로직을 관리하기 쉽게 만들며, 필요한 스토어만 로드하여 성능을 향상시킬 수 있습니다. ​다른 스토어를 `import`하여 `use` 키워드로 쉽게 접근하고 활용할 수 있어 스토어 간의 교차 조합도 유연하게 지원합니다. 스토어는 도메인별(예: ​사용자, 장바구니, 제품 등)로 분리하여 관리하는 것이 권장됩니다.

### SSR (서버사이드 렌더링) 지원
Pinia는 SSR 환경에서도 원활하게 작동하도록 설계되었습니다. `useStore()` 함수를 `setup` 함수, `getters`, `actions` 상단에 호출하는 한 SSR 환경에서 스토어 생성이 기본적으로 작동합니다. SSR 환경에서는 초기 상태를 수화(hydrate)하기 위해 루트 상태(rootState)를 HTML에 포함시켜야 합니다. `devalue`와 같은 라이브러리를 사용하여 상태를 직렬화하고 XSS 공격으로부터 보호하는 것이 권장됩니다. Nuxt와 같은 프레임워크를 사용하는 경우에는 Nuxt 전용 지침을 따르는 것이 좋습니다.

### 플러그인 확장성
Pinia는 플러그인 시스템을 통해 기능을 확장할 수 있습니다. ​플러그인은 스토어에 추가할 속성을 반환하는 함수로, 로컬 스토리지 동기화, 액션 로깅, 트랜잭션 등 다양한 전역 기능을 구현하는 데 유용합니다. ​예를 들어, `pinia-plugin-persistedstate` 플러그인을 사용하면 스토어의 상태를 `localStorage`나 `sessionStorage`에 저장하고 복원할 수 있습니다. ​이를 통해 사용자가 페이지를 새로고침하거나 다른 페이지로 이동해도 이전 상태를 유지하여 사용자 경험을 향상시킬 수 있습니다.

### `$patch`를 이용한 상태 변경
​컴포넌트에서 여러 상태를 한 번에 변경해야 할 때, 각각의 반응성 트리거로 인해 불필요한 렌더링이 발생할 수 있습니다. Pinia는 `$patch` 메서드를 사용하여 여러 상태 변경을 단일 작업으로 처리할 수 있게 합니다. `$patch`는 객체 형태로 변경할 상태를 전달하거나​, 콜백 함수 형태로 상태 객체를 전달받아 자유롭게 변경할 수 있습니다. ​이는 불필요한 반응성 트리거를 방지하고 가독성을 높입니다. `$patch`는 `actions` 내에서도 `this.$patch` 형태로 사용할 수 있습니다.

### `$subscribe` 및 `$onAction`

Pinia는 `$subscribe` 메서드를 통해 스토어의 상태가 변경될 때마다 콜백 함수를 실행할 수 있게 합니다. ​이는 주로 상태 변화에 따라 로컬 스토리지에 저장하거나 외부와 동기화할 때 사용됩니다. ​콜백 함수는 변경 정보(`mutation`)와 변경된 상태 객체(`state`)를 인수로 받으며, mutation.type 속성을 통해 상태가 직접 수정되었는지, `$patch` 메서드로 변경되었는지 등을 구분할 수 있습니다.

​또한, `$onAction` 메서드를 사용하여 스토어의 `action` 호출을 구독하고, `action`이 실행될 때 콜백을 실행할 수 있습니다. ​이는 `action` 실행 전후의 동작을 감지하거나 로깅할 때 유용합니다.

### `$reset` 및 `$dispose`

Pinia 스토어는 `$reset()` 메서드를 호출하여 변경된 모든 상태를 초깃값으로 되돌릴 수 있습니다. ​그러나 `$reset()` 메서드는 Options API 방식으로 작성된 스토어에서만 기본적으로 동작하며​, Composition API 스타일의 Setup Stores에서는 별도의 플러그인을 통해 구현해야 합니다.

​스토어가 더 이상 필요 없을 때는 `$dispose()` 메서드를 사용하여 스토어를 완전히 제거하고 메모리에서 해제할 수 있습니다.

```ts
// Setup Store 에서 직접 $reset() 메서드를 만들어 사용
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)

  function $reset() {
    count.value = 0
  }

  return { count, $reset }
})
```

## Pinia 통합 및 사용법
### 설치 및 기본 설정
Pinia를 Vue.js 애플리케이션에 통합하는 과정은 매우 간단합니다.
1. Pinia 패키지 설치
```bash[pnpm]
pnpm add pinia
```

2. Vue 앱에 등록
`main.js` 또는 `main.ts` 파일에서 `createPinia`를 임포트하고 Pinia 인스턴스를 생성한 후, `app.use()` 메서드를 통해 Vue 애플리케이션에 플러그인으로 등록합니다.

```ts
import { createApp } from 'vue';
import { createPinia } from 'pinia';
import App from './App.vue';

const app = createApp(App);
const pinia = createPinia();
app.use(pinia);
app.mount('#app');
```

### 컴포넌트에서의 활용
​컴포넌트에서 Pinia 스토어를 사용하려면, 먼저 스토어 파일을 임포트하고 `use` 키워드가 붙은 함수를 호출하여 스토어 인스턴스를 가져옵니다. 가져온 스토어 인스턴스의 속성에 직접 접근하여 `state` 값(예: `counter.count`)을 읽거나, `actions` 메서드(예: `counter.increment()`)를 호출하여 상태를 변경할 수 있습니다.

### `storeToRefs`를 이용한 반응성 유지
Pinia 스토어는 반응형 객체로 감싸져 있기 때문에, 스토어 인스턴스를 구조 분해 할당(`destructuring`)하면 반응성을 잃을 수 있습니다. 이러한 문제를 피하고 `state`와 `getters`의 반응성을 유지한 채로 구조 분해 할당을 사용하려면 Pinia에서 제공하는 `storeToRefs` 헬퍼 함수를 사용해야 합니다. `actions`는 일반 함수이므로 `storeToRefs` 없이도 구조 분해 할당해도 반응성에 영향을 주지 않습니다.
```vue
<script setup lang="ts">
import { useCounterStore } from '@/stores/counter'

// ❌ storeToRefs를 사용하지 않고 구조분해
const { count, doubleCount, increment } = useCounterStore()

// -------------------------------------------------
const counter = useCounterStore()
// ✅ storeToRefs로 state와 getter를 반응형으로 변환
const { count, doubleCount } = storeToRefs(counter)

// actions는 일반 함수이므로 직접 구조분해해도 괜찮음
const { increment } = counter
</script>

<template>
  <div>
    <p>count: {{ count }}</p>
    <p>doubleCount: {{ doubleCount }}</p>
    <button @click="increment">+</button>
  </div>
</template>
```

### Nuxt 통합
Pinia는 Nuxt.js 프레임워크와도 원활하게 통합됩니다. `@pinia/nuxt` 모듈을 설치하고 `nuxt.config.ts` 파일에 모듈을 등록하는 것으로 기본적인 설정이 완료됩니다. Nuxt 3 환경에서는 `usePinia()` 메서드를 통해 Pinia 인스턴스에 접근하거나, `useNuxtApp()`에서 `$pinia`를 통해 접근할 수 있습니다.

## Convention Guide
스토어를 정의하는 방법에는 Option Store와 Setup Store 두 가지가 있지만, Setup Store 방식을 사용할 것을 권장합니다. 

### 목적
- 프로젝트 전반에서 **통일된 스토어 작성 방식** 유지
- Composition API 스타일과 호환성을 높여 **유연하고 재사용 가능한 스토어** 구현
- TypeScript 지원과 반응성 처리의 명확성을 보장
```ts
// stores/counter.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useCounterStore = defineStore('counter', () => {
  // state
  const count = ref(0)

  // getter
  const doubleCount = computed(() => count.value * 2)

  // action
  const increment = () => {
    count.value++
  }

  // $reset
  const $reset = () => {
    count.value = 0
  }

  return { count, doubleCount, increment, $reset}
})
```

### 권장 이유
| 항목            | 설명                                   |
| -------------- | ------------------------------------- |
| Composition API 친화적 | `ref`, `reactive`, `computed`를 자연스럽게 사용 가능 |
| TypeScript 지원 우수 | 반환된 상태, getter, action 모두 타입 추론 가능 |
| Composable과 결합 용이 | 다른 store나 composable을 쉽게 가져와 조합 가능 |
| 비동기 처리 편리 | async/await를 action 내부에서 바로 사용 가능 |
| 유연성 | Setup Store 내부에서 상태, getter, 액션을 자유롭게 구성 가능 |

> **💡스토어 작성 규칙**
> 1. 모든 신규 스토어는 **Setup Store 방식**으로 작성합니다.
> 2. State, Getter, Action을 Setup Store 내부에서 정의하고 반환합니다.
> 3. 구조분해 시 `storeToRefs()`를 사용하여 반응성을 유지합니다.