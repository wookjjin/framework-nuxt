---
title: Composable
description: 재사용 가능한 컴포넌트와 컴포저블을 효율적으로 작성하는 방법을 학습합니다.
navigation:
  icon: i-lucide-square-function
---

## Overview
**첫 번째로**, 명확한 목적과 역할을 가진 컴포넌트를 설계하는 것이 중요합니다. 컴포넌트는 하나의 특정 기능에 집중해야 하며, 불필요하게 복잡한 동작이나 역할을 포함하지 않도록 해야 합니다. 이를 통해 다른 프로젝트에서도 쉽게 재활용할 수 있는 유연성이 생깁니다.

**두 번째로**, 컴포넌트와 컴포저블은 가능한 한 독립적으로 동작하도록 설계해야 합니다. 이는 내부 상태나 의존성을 최소화하여 외부에서 쉽게 가져다 사용할 수 있도록 만든다는 의미입니다. 필요하다면 이벤트 전달 또는 데이터 바인딩과 같은 매커니즘을 활용하여 유기적으로 연결될 수 있게 설계하면 됩니다.

또한, 추상화 레벨을 적절히 조정하는 것이 효율적인 작성법의 핵심입니다. 너무 많은 세부사항을 숨기거나 너무 광범위하게 설정하면 오히려 사용이 어려워질 수 있으므로, 사용자 관점에서 편리하면서도 직관적으로 이해할 수 있는 설계를 목표로 해야 합니다.

**마지막으로**, 문서화 및 개방형 구조를 고려해야 합니다. 다른 사용자 또는 팀원이 컴포넌트를 활용할 때 필요한 정보를 쉽게 찾고 이해할 수 있도록 체계적인 가이드나 주석을 제공하는 것이 도움이 됩니다.

효율적인 컴포넌트를 작성하는 전 과정에서 코드 리뷰와 테스트를 적극적으로 활용하는 것도 잊지 말아야 합니다. 이렇게 함으로써 완성된 컴포넌트의 품질을 높이고, 예기치 못한 문제를 발생시키지 않는 믿음직한 코드를 작성할 수 있습니다.

**궁극적으로는** 이런 원칙과 기술을 충실히 따른다면 재사용성과 확장성을 겸비한 훌륭한 코드 개발의 첫걸음을 성공적으로 내딛을 수 있습니다. 이를 통해 개발자는 더 나은 생산성과 유지 관리 효율성을 경험할 수 있을 것입니다.

## Composable?
Vue에서 컴포저블(Composable)이란 재사용 가능한 로직을 정의하고 활용하기 위한 구조 또는 함수입니다. 이는 Vue 3에서 도입된 Composition API의 주요 개념 중 하나로, 특히 코드의 모듈화와 효율적인 관리에 도움을 주기 위해 설계되었습니다. 컴포저블은 Vue 컴포넌트의 로직을 다른 컴포넌트끼리 공유할 수 있도록 하는 방식으로, 특정 기능이나 상태 관리 로직을 함수로 캡슐화해 제공합니다.

즉, **Vue Composition API를 활용하여 상태 저장 로직을 캡슐화하고 재사용하는 함수입니다.**

### 1. 기본 예제 (useCounter)
Composable의 가장 단순한 형태로, **상태와 로직을 함께 재사용**할 수 있는 예시입니다.

```ts
// composables/useCounter.ts
import { ref } from 'vue'

export function useCounter() {
  const count = ref(0)
  const increment = () => count.value++
  const decrement = () => count.value--
  const reset = () => (count.value = 0)

  return { count, increment, decrement, reset }
}
```

```vue
<!-- Counter.vue -->
<script setup lang="ts">
import { useCounter } from '@/composables/useCounter'

const { count, increment, decrement, reset } = useCounter()
</script>

<template>
  <div class="p-4 text-center">
    <p>Count: {{ count }}</p>
    <button @click="increment">+</button>
    <button @click="decrement">-</button>
    <button @click="reset">Reset</button>
  </div>
</template>
```
- `useCounter` 내부에서 상태(`count`)가 관리됩니다.
- 여러 컴포넌트에서 동일한 로직을 사용가능합니다.

### 2. 라이프사이클이 포함된 예제 (useMouse)
`onMounted`, `onUnmounted` 같은 생명주기 훅을 Composable 내부에서 직접 사용할 수 있습니다.
```ts
// composables/useMouse.ts
import { ref, onMounted, onUnmounted } from 'vue'

export function useMouse() {
  const x = ref(0)
  const y = ref(0)
  
  const update = (event: MounseEvent) => { 
    x.value = event.pageX
    y.value = event.pageY
  }

  onMounted(() => window.addEventListner('mousemove', update))
  onUnmounted(() => window.removeEventListner('mousemove', update))

  return { x, y }
}
```
```vue
<!-- MouseTracker.vue -->
<script setup lang="ts">
import { useMouse } from '@/composables/useMouse'

const { x, y } = useMouse()
</script>

<template>
  <p>Mouse position: {{ x }}, {{ y }}</p>
</template>

```
- Composable 내부에서도 생명주기 훅(onMounted, onUnmounted) 사용 가능합니다.
- 로직이 한 곳에 모여 유지보수가 용이합니다.
### 3. 비동기 로직 예제 (useFetch)
실무에서 자주 활용되는 방식으로, 비동기 데이터 요청 로직을 추상화한 예제를 소개합니다.
```ts
// composables/useFetch.ts
import { ref } from 'vue'

export function useFetch<T>(url: string) {
  const data = ref<T | null>(null)
  const loading = ref(false)
  const error = ref<Error | null>(null)

  const fetchData = async () => {
    loading.value = true
    error.value = null
    try {
      const res = await fetch(url)

      if (!res.ok)
        throw new Error('Failed to fetch')
      data.value = await res.json()
    }
    catch (e) {
      error.value = e as Error
    }
    finally {
      loading.value = false
    }
  }

  fetchData()
  return { data, loading, error, refetch: fetchData }
}

```
```vue
<!-- PostList.vue -->
<script setup lang="ts">
import { useFetch } from '@/composables/useFetch'

const { data, loading, error } = useFetch<any[]>('https://jsonplaceholder.typicode.com/posts')
</script>

<template>
  <div v-if="loading">Loading...</div>
  <div v-else-if="error">{{ error.message }}</div>
  <ul v-else>
    <li v-for="post in data" :key="post.id">{{ post.title }}</li>
  </ul>
</template>
```
- 비동기 처리 상태(loading, error, data)를 일관되게 관리 가능합니다.

### 4. Composable 작성 시 팁
- 항상 `use`로 시작하는 네이밍 규칙
- 필요한 경우 반환 타입 명시 (`<T>` 제네릭)
- 내부에서 `ref`, `computed`, `watch`, `onMounted` 등을 자유롭게 사용 가능

| 항목 | 설명 |
|------|------|
| 네이밍 규칙 | 항상 `use`로 시작합니다. 예: `useUser`, `useAuth`, `useTheme` |
| 반환 값 | 객체 형태로 반환하여 구조분해 할당(`const { x } = useSomething()`)에 유리하도록 합니다. |
| 상태 관리 | 각 composable은 독립적인 상태를 가집니다. 여러 컴포넌트에서 호출해도 서로 영향을 주지 않습니다. |
| 전역 상태 | 전역으로 상태를 공유해야 한다면 `Pinia`나 `provide/inject`를 활용하세요. |
| 내부 구성 | `ref`, `computed`, `watch`, `onMounted` 등을 자유롭게 사용할 수 있습니다. |
| 타입 지원 | TypeScript의 제네릭(`<T>`)을 사용하여 유연하고 타입 안전한 composable을 만듭니다. |
| 책임 분리 | 하나의 composable은 **하나의 역할(로직 단위)**만 담당하도록 작게 나누는 것이 좋습니다. |
| 테스트 | composable은 순수 함수처럼 동작하므로 단위 테스트 작성이 용이합니다. |

### 5. 정리
Composable은 Vue의 Composition API를 최대한 활용하여 “상태 + 로직 + 생명주기”를 캡슐화한 재사용 가능한 함수입니다.
::note 
핵심 요약 
- 로직 재사용성과 코드 가독성을 높임
- 유지보수성 향상
- Vue의 반응형 시스템과 자연스럽게 통합됨
::

## 컴포넌트 심화: 재사용 가능한 컴포넌트 작성
Vue 컴포넌트는 사용자 인터페이스를 구성하는 핵심 요소입니다.  
그러나 프로젝트 규모가 커질수록 유지보수를 고려한 **재사용 가능한 컴포넌트 설계**가 중요해집니다.

### 1. 재사용 컴포넌트란?
> 재사용 컴포넌트는 다양한 페이지나 기능에서 **동일한 UI 로직을 반복하지 않도록** 설계된 요소입니다.

예를 들어, 동일한 버튼 스타일을 여러 군데에서 적용해야 한다면,  
공통 로직을 한 군데에 모아 정의해 두는 것이 유지보수를 훨씬 더 수월하게 만듭니다.

### 2. Props로 데이터 전달하기
부모 컴포넌트는 **props**를 통해 자식 컴포넌트로 데이터를 전달합니다.
```vue
<!-- BaseButton.vue -->
<script setup lang="ts">
defineProps({
  label: {
    type: String,
    required: true,
  },
  type: {
    type: String,
    default: 'button',
  },
})
</script>

<template>
  <button :type="type" class="base-button">
    {{ label }}
  </button>
</template>

<!-- 사용 예시 -->
<BaseButton label="저장" type="submit" />
<BaseButton label="취소" />
```

### 3. Emit으로 이벤트 전달하기
자식 컴포넌트는 emit을 통해 부모에게 이벤트를 알립니다.
```vue
<!-- BaseButton.vue -->
<script setup lang="ts">
const emit = defineEmits(['click'])
</script>

<template>
  <button @click="emit('click')" class="base-button">
    <slot />
  </button>
</template>

<!-- 사용 예시 -->
<BaseButton @click="saveData">저장</BaseButton>
```

### 4. v-model을 활용한 양방향 데이터 바인딩
사용자 정의 컴포넌트에서도 v-model을 지원할 수 있습니다.
```vue
<!-- BaseInput.vue -->
<script setup lang="ts">
const props = defineProps<{ modelValue: string }>()
const emit = defineEmits(['update:modelValue'])

const onInput = (e: Event) => {
  emit('update:modelValue', (e.target as HTMLInputElement).value)
}
</script>

<template>
  <input :value="props.modelValue" @input="onInput" class="base-input" />
</template>

<!-- 사용 예시 -->
<BaseInput v-model="username" />
```

### 5. Slot으로 유연한 구조 만들기
Slot은 부모 컴포넌트가 콘텐츠를 자식에 삽입할 수 있게 해줍니다.
```vue
<!-- BaseCard.vue -->
<template>
  <div class="card">
    <header><slot name="header" /></header>
    <section><slot /></section>
    <footer><slot name="footer" /></footer>
  </div>
</template>

<!-- 사용 예시 -->
<BaseCard>
  <template #header>프로필</template>
  <p>사용자 정보</p>
  <template #footer>2025-10-14</template>
</BaseCard>
```
- 슬롯을 사용하면 부모가 컴포넌트 구조를 유연하게 제어할 수 있습니다.  
- 스코프드 슬롯을 활용하면 데이터 전달도 가능하여 더욱 효율적인 구성과 데이터 바인딩이 가능합니다.

### 6. 재사용성 향상을 위한 패턴
| 패턴                             | 설명                                              |
| ------------------------------ | ----------------------------------------------- |
| **Base 컴포넌트 패턴**               | `BaseButton`, `BaseInput`처럼 전역적으로 사용하는 공통 UI 정의 |
| **Composables + Component 결합** | 비즈니스 로직은 composable에, UI는 component에 분리         |
| **확장 가능한 Props 구조**            | Props에 `variant`, `size`, `color` 등 옵션 제공       |
| **템플릿 유연화**                    | Slot을 적극 활용하여 레이아웃 변경을 쉽게 만듦                    |
| **UI 라이브러리화**                  | 일관된 디자인 시스템을 유지하기 위해 공통 컴포넌트를 모듈화               |

> 재사용 가능한 컴포넌트는 “유연성과 일관성”의 균형을 잘 잡는 것이 핵심입니다.
