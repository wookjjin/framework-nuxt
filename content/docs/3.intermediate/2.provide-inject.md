---
title: Provide/Inject
description: provide/inject를 활용하여 데이터를 바로 전달하는 방법을 학습합니다. 
navigation: 
  icon: i-lucide-network
---

## Overview
Vue.js의 `provide`와 `inject` 기능은 컴포넌트 계층 구조 내에서 데이터를 효율적으로 전달하고 관리하기 위한 강력한 의존성 주입 메커니즘입니다. 이 기능은 특히 대규모 애플리케이션이나 복잡하게 중첩된 컴포넌트 구조에서 "props drilling"이라는 문제를 해결하는 데 매우 유용합니다.

## Provide/Inject의 핵심 개념 및 목적
`provide/inject`는 Vue.js 컴포넌트 간 데이터 통신 방법 중 하나로, 부모 컴포넌트에서 하위 컴포넌트로 데이터를 전달하는 데 사용됩니다. 이는 전통적인 `props` 기반 데이터 전달 방식의 한계를 극복하기 위해 설계되었습니다.

![Provide/Inject](https://v3-docs.vuejs-korea.org/assets/provide-inject.2d638840.png)
출처: [Vue.js](https://ko.vuejs.org/)

### 1. prop drilling 문제 해결
일반적으로 부모-자식 컴포넌트 간 데이터 전달은 `props`를 통해 이루어집니다. 하지만 컴포넌트 계층 구조가 깊어질수록 먼 조상 컴포넌트의 데이터를 가장 깊은 하위 컴포넌트가 필요로 하는 경우, 중간에 위치한 수많은 컴포넌트들이 해당 `prop`을 사용하지 않음에도 불구하고 단수히 전달하는 역할을 해야 하는 비효율적인 상황이 발생합니다. 이러한 현상을 'prop drilling' 또는 'prop chaining'이라고 부르며, 코드의 복잡성을 증가시키고 유지보수를 어렵게 만듭니다. `provide/inject`는 이러한 `prop drilling` 문제를 우회하여 상위 컴포넌트가 데이터를 제공하면, 하위 컴포넌트들은 깊이에 상관없이 해당 데이터를 직접 '주입(inject)'받아 사용할 수 있도록 합니다.

![Prop Drilling](https://v3-docs.vuejs-korea.org/assets/prop-drilling.5af51664.png)
출처: [Vue.js](https://ko.vuejs.org/)

### 2. 의존성 주입 패턴
`provide/inject`는 의존성 주입(Dependency Injection) 패턴을 Vue.js에 구현한 것입니다. 부모 컴포넌트가 `제공자(provider)` 역할을 하여 특정 데이터나 서비스를 제공하고, 모든 자손 컴포넌트는 `주입자(injector)` 역할을 하여 이 데이터를 필요한 시점에 주입받을 수 있습니다. 이는 컴포넌트 간의 결합도를 낮추고, 재사용성을 높이는 데 기여합니다.

## Provide/Inject의 기본 사용법 및 문법
`provide/inject`는 `provide()` 함수와 `inject()` 함수를 사용하여 구현됩니다.

### 1. `provide()` 함수 사용법
`provide()` 함수는 상위 컴포넌트에서 데이터를 제공하기 위해 사용됩니다. 이 함수는 두 개의 인자를 받습니다.
- **첫 번째 인자**: 주입 키(injection key)로, 문자열 또는 `Symbol`이 될 수 있습니다. 이 키는 하위 컴포넌트에서 원하는 값을 조회하는 데 사용되는 고유한 식별자입니다. 하나의 컴포넌트에서 여러 값을 제공하기 위해 여러 `injection key`를 사용하여 `provide()`를 여러 번 호출할 수 있습니다.
- **두 번째 인자**: 제공되는 값으로, `ref`와 같은 반응형 상태를 포함한 모든 유형의 값이 될 수 있습니다. 반응형 값을 제공하면 제공된 값을 사용하는 하위 컴포넌트가 제공자 컴포넌트에 대한 반응형 연결을 설정할 수 있습니다.

**코드 예시 (Composition API script setup)**:
```vue
<script setup lang="ts">
const message = ref('Hello from Parent!')
provide('message', message)
</script>

<template>
  <div>
    <h1>Parent Component</h1>
    <ChildComponent />
  </div>
</template>
```

**애플리케이션 레벨 provide**:
컴포넌트 내에서 데이터를 제공하는 것 외에도, `main.js`와 같은 애플리케이션 진입점에서 `app.provide()`를 사용하여 앱 전체 레벨에서 데이터를 제공할 수 있습니다. 애플리케이션 레벨에서 제공된 값은 앱 내의 모든 컴포넌트에서 주입받아 사용할 수 있으며, 이는 플러그인을 작성할 때 특히 유용합니다.
```main.js
import { createApp } from 'vue'
import App from '.App.vue'

const app = createApp(App)
app.provide('appMessage', 'Hello from App Level!') // 앱 전체에 'appMessage' 제공
app.mount('#app')
```

### 2. `inject()` 함수 사용법
`inject()` 함수는 상위 컴포넌트 또는 애플리케이션 레벨에서 제공된 데이터를 주입받기 위해 사용됩니다.
- **첫 번쨰 인자**: 주입 키로, `provide()` 시 사용된 키와 동일해야 합니다. Vue는 키가 일치하는 값을 찾기 위해 상위 체인을 단계쩍으로 탐색하며, 여러 부모가 동일한 키를 제공하는 경우 주입될 컴포넌트에 가장 가까운 부모의 값이 제공됩니다.
- **두 번째 인자(optional)**: 기본값(default value)으로, 주입 키에 해당하는 값이 상위 체인에 없을 경우 사용됩니다. 기본값을 제공하면 런타임 경고를 피할 수 있습니다.
- **세 번째 인자(optional)**: 기본값이 함수인 경우, 해당 함수를 팩토리 함수로 처리하질 여부를 지정하는 부울 값입니다. `true`로 설정하면 함수가 호출되어 반환 값을 기본값으로 사용하고, `false` 또는 생략 시 함수 자체를 값으로 사용합니다. Vue 공식 문서에서는 현재 이 세 번째 인자의 기본 동작과 관련한 이슈가 있어 명시적으로 값을 지정하는 것을 권장합니다.

**코드 예시(Composition API script setup)**:
```vue
<script setup>
const message = inject('message') // 'message' 키로 제공된 값 주입
const appMessage = inject('appMessage') // 앱 레벨에서 제공된 값 주입
const defaultValue = inject('nonExistentKey', 'Default Value') // 기본값 설정
const factoryValue = inject('expensiveKey', () => new ExpensiveClass(), true) // 팩토리 함수 사용
</script>

<template>
  <div>
    <p>Injected Message: {{ message }}</p>
    <p>App-level Message: {{ appMessage }}</p>
    <p>Default Value: {{ defaultValue }}</p>
  </div>
</template>
```

## Provide/Inject의 동작 원리 및 내부 메커니즘
`provide/inject`는 Vue 컴포넌트 트리를 기반으로 동작하는 의존성 주입 시스템입니다.

### 1. 컴포넌트 트리 내 데이터 전달 방식
상위 컴포넌트가 `provide`로 데이터를 제공하면, 이 값은 해당 컴포넌트의 모든 하위 컴포넌트(중첩 깊이에 상관없이)에서 `inject`를 통해 접근할 수 있게 됩니다. Vue는 `inject`호출 시 제공된 키와 일치하는 ㄱ밧을 찾기 위해 컴포넌트 트리의 상위 체인을 탐색합니다. 만약 여러 부모 컴포넌트가 동일한 키를 제공하면, `inject`를 호출한 컴포넌트로부터 가장 가까운 부모 컴포넌트의 값이 주입됩니다. 이러한 방식은 `prop drilling`을 효과적으로 방지하고, 중간 컴포넌트가 불필요한 `prop`을 선언하고 전달할 필요가 없게 만듭니다.

### 2. 반응성 처리
`provide/inject` 바인딩은 기본적으로 반응형이 아닙니다. 이는 `provide`된 데이터가 단순히 원시 값(primitive value)이거나 일반 객체일 경우, `provide`하는 컴포넌트에서 값이 변경되어도 `inject`하는 컴포넌트에는 그 변경 사항이 자동으로 반영되지 않음을 의미합니다.

하지만 Vue 3의 Composition API에서는 `ref()`나 `reactive()`와 같은 반응형 API로 감싼 값을 `provide`하면 이 문제가 해결됩니다. 이렇게 반응형으로 제공된 값은 `inject`하는 컴포넌트에서도 반응형 연결을 유지하므로, 제공자 컴포넌트에서 값이 변경되면 주입자 컴포넌트에서도 자동으로 업데이트됩니다.

### 3. 반응형 데이터 제공 및 변경 모범 사례
반응형 `provide/inject`값을 사용할 때는 가능한 모든 상태 변화를 제공자(provider) 컴포넌트 내부에 두는 것이 권장됩니다. 이는 제공된 상태와 그 변경 로직이 동일한 컴포넌트에 위치하여 유지보수를 용이하게 합니다. 만약 주입자(injector) 컴포넌트에서 데이터를 업데이트해야 하는 경우, 상태를 변경하는 책임을 지닌 함수를 함께 `provide`하는 것이 바람직합니다.
```vue
<!-- Provider Component -->
<script setup>
const location = ref('North Pole')

function updateLocation() {
  location.value = 'South Pole'
}

provide('locationData', {
  location,
  updateLocation
})
</script>

<!-- Injector Component -->
<script setup>
import { inject } from 'vue'

const { location, updateLocation } = inject('locationData')
</script>

<template>
  <button @click="updateLocation">{{ location }}</button>
</template>
```

### 4. `readonly()`를 이용한 불변성 확보
`inject`된 데이터가 하위 컴포넌트에 의해 변경되지 않도록 하려면, `provide` 시 해당 값을 `readonly()`로 래핑하여 전달할 수 있습니다. 이는 Vue의 단방향 데이터 흐름 원칙을 유지하고 데이터 변경의 출처를 명확히 하는 데 도움을 줍니다.

## Provide/Inject의 주요 활용 사례
`provide/inject`는 다양한 상황에서 유용하게 활용될 수 있으며, 특히 특정 문제를 해결하는 데 강점을 보입니다.

### 1. prop drilling 방지
가장 대표적인 활용 사례는 깊게 중첩된 컴포넌트 트리에서 `prop drilling`을 방지하는 것입니다. 상위 컴포넌트가 데이터를 한 번 `provide`하면, 중간 컴포넌트들은 해당 `prop`을 선언하거나 잔달할 필요 없이, 필요한 하위 컴포넌트에서 직접 `inject`하여 사용할 수 있습니다. 이는 코드의 가독성을 높이고 불필요한 보일러플레이트 코드를 줄여줍니다.

### 2. 플러그인 및 컴포넌트 라이브러리 개발
`provide/inject`는 Vue.js 플러그인이나 컴포넌트 라이브러리를 개발할 때 특히 강력한 도구로 활용됩니다. 플러그인이나 라이브러리는 일반 애플리케이션보다 복잡한 구조를 가지지 않고 단일 모듈 형태로 되어있는 경우가 많으므로, `provide.inject`를 통해 전역적인 설정값, 유틸리티 함수, 또는 특정 서비스를 컴포넌트 트리 전체에 효율적으로 주입할 수 있습니다. 
> 로그인 정보, 테마 설정, API 클라이언트, 로깅 유틸리티 등 앱 전체에서 공유하는 데 사용될 수 있습니다.

### 3. 서비스 및 컨텍스트 주입
`provide/inject`는 컴포넌트 간에 서비스를 공유할 때 의존성 주입 패턴으로 사용될 수 있습니다. 예를 들어, 로깅 서비스를 여러 컴포넌트에 주입하여 컴포넌트와 서비스 구현을 분리하고 재사용성을 높일 수 있습니다. 또한, UI 라이브러리에서 `provide/inject`를 사용하여 폼 유효성 검사 상태(`allowSubmit`)와 같은 폼 컨텍스트를 하위 컴포넌트에 제공하여, 깊이 중첩된 폼 요소들이 사위 폼의 상태에 따라 동적으로 반응하게 할 수 있습니다.

### 4. 대규모 애플리케이션에서의 Symbol 키 사용
대규모 애플리케이션이나 여러 개발자가 협업하는 프로젝트에서는 문자열 `injection key`의 잠재적인 충돌 위험이 있습니다. 이를 피하기 위해 `Symbol`을 `injection key`로 사용하는 것이 강력히 권장됩니다. `Symbol`은 고유한 값을 가지므로 이름 충돌 없이 고유한 식별자로 사용될 수 있으며, `injection key`를 별도의 파일에 정의하여 `export`하고 필요한 곳에서 `import`하여 사용함으로써 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.
```ts
// keys.js (공유 파일)
export const registerKey = Symbol('RegisterKey')

// 부모 컴포넌트
import { registerKey } from './keys'
provide(registerKey, someValue)

// 손자 컴포넌트
import { registerKey } from './keys'
const injected = inject(registerKey) // ✅ 정상 작동
```

### 5. 테스트 전략 및 모킹(Mocking)
`provide/inject`는 Vue 애플리케이션의 테스트를 간소화하는 데 매우 효과적입니다. 특히 특정 종속성을 모의(mock)해야 할 때 유용합니다. 모의된 종속성, 상태 또는 서비스를 주입함으로써 테스트 중인 컴포넌트를 격리하고 해당 종속성의 동작을 제어할 수 있습니다. 예를 들어, `LoggerService`와 같은 서비스의 실제 구현 대신 모의 객체를 주입하여 컴포넌트의 로깅 기능을 테스트할 수 있습니다. `AuthService`의 `isAuthenticated` 메서드를 모의하여 로그인/로그아웃 상태를 시뮬레이션하고 컴포넌트 동작을 검증하는 것도 가능합니다. `storybook-vue3-router`와 같은 라이브러리를 사용하면 스토리북 환경에서 라우터(`query`, `parms`) 값을 `mockRouter`로 쉽게 모킹할 수 있으며, `provide` 값을 직접 설정하여 컴포넌트의 `inject` 값들을 모킹하는 것도 가능합니다.

## Provide/Inject의 단점 및 주의사항
`provide/inject`는 강력한 기능이지만, 모든 상황에 만능 해결책은 아니며 몇 가지 중요한 단점과 주의사항이 존재합니다. Vue.js 공식 가이드에서도 일반 애플리케이션 코드에서는 사용하지 않는 것이 좋다고 언급하기도 합니다.

### 1. 데이터 흐름의 불명확성 및 디버깅 어려움
`props`와 달리 `provide/inject`는 데이터 전달 경로가 명시적이지 않아, 데이터 흐름을 추적하기 어렵게 만들 수 있습니다. 이는 특정 데이터가 어디서 제공되었고, 어느 컴포넌트에서 주입받아 사용되는지 파악하기 어렵게 하여 코드 유지보수를 복잡하게 만듭니다. 또한, Vue 개발 도구에서 `inject`된 값을 직접적으로 검사하기 어렵기 때문에 디버깅이 더 어려울 수 있습니다.

### 2. 컴포넌트 간 결합도 증가 및 재사용성 저하
`provide/inject`를 과도하게 사용하면 컴포넌트가 주입된 값에 지나치게 의존하게 되어 컴포넌트 간의 결합도가 높아질 수 있습니다. 이는 해당 컴포넌트를 다른 컨텍스트에서 재사용하기 어렵게 만들고, 궁극적으로 컴포넌트의 재사용성을 저하시킵니다.

### 3. 전역 상태 관리와의 혼동
`provide/inject`가 앱 레벨에서 사용될 경우 전역 상태 관리 라이브러리와 유사하게 보일 수 있어 혼동을 줄 수 있습니다. 하지만 `provide/inject`는 주로 컴포넌트 계층 구조 내의 로컬 상태 공유나 특정 서비스 주입에 더 적합하며, 복잡한 전역 상태 관리에는 Vuex나 Pinia를 사용하는 것이 더 바람직합니다.

### 4. 모범 사례 및 완화 전략
이러한 단점들을 완화하기 위해 다음과 같은 규칙이 권장됩니다.
- 문서화 및 명명 규칙: `provide/inject` 관계를 명확히 문서화하고, 주입된 키에 대해 명확하고 일관된 명명 규칙을 사용해야 합니다.
- 추상화된 서비스 주입: 컴포넌트의 재사용성을 높이기 위해 구체적인 데이터보다는 추상화된 서비스나 인터페이스를 주입하는 것을 고려해야 합니다.
- Composable로 로직 분리: `provide` 로직이 복잡해길 경우 `composable` 함수로 분리하여 컴포넌트의 가독성과 유지보수성을 높일 수 있습니다.
- 기본값 및 예외 처리: `inject` 시에는 항상 기본값을 설정하거나, 제공된 키가 없을 경우를 대비하여 `requireInjection`과 같은 유틸리티 함수를 통해 명시적인 예외 처리를 구현해야 합니다.
- `readonly()` 사용: 하위 컴포넌트에서 `inject`된 반응형 값을 의도치 않게 변경하는 것을 방지하기 위해 `readonly()`로 래핑하여 `provide`해야 합니다.

## 다른 데이터 전달 방식과의 비교
Vue.js에서 컴포넌트 간 데이터를 전달하고 상태를 관리하는 방법은 provide/inject 외에도 여러 가지가 있습니다. ​각 방법은 고유한 장단점과 적합한 사용 시나리오를 가지고 있습니다.

### 1. Props (속성)

`Props`는 부모 컴포넌트에서 바로 아래 자식 컴포넌트로 데이터를 단방향으로 전달하는 가장 기본적이고 직관적인 방법입니다. ​데이터 흐름이 명확하고 간단한 컴포넌트 구조에서 사용하기 용이합니다. ​그러나 컴포넌트 깊이가 깊어지면 `prop drilling` 문제가 발생하여 비효율적입니다.

### 2. Event Bus

`Event Bus`는 컴포넌트 트리에 관계없이 전역 이벤트를 사용하여 컴포넌트 간 통신을 가능하게 하는 방식입니다. ​과거에는 중첩된 컴포넌트 간 통신에 사용되었으나, Vue 3에서는 `provide/inject`나 상태 관리 라이브러리(Vuex/Pinia)와 같은 더 나은 대안이 많아 권장되지 않는 방식입니다. ​데이터 흐름을 추적하기 어렵고 유지보수가 복잡해지는 단점이 있습니다.

### 3. Vuex / Pinia (전역 상태 관리 라이브러리)

`Vuex`와 `Pinia`는 Vue 애플리케이션의 전역 상태(global state)를 중앙 집중식으로 관리하기 위한 공식 상태 관리 라이브러리입니다. ​복잡하고 대규모인 애플리케이션에서 여러 컴포넌트가 공유하는 상태를 체계적으로 관리하고, 상태 변화를 예측 가능한 방식으로 처리할 수 있도록 돕는다. `provide/inject`가 특정 컴포넌트 계층 내의 종속성 주입에 더 적합하다면, `Vuex`/`Pinia`는 앱 전체의 일관된 상태 관리에 강점을 보입니다.

| 구분 | Props | Provide/Inject | Vuex/Pinia | Event Bus |
|------|---------|------------|-----------|---------------------|
| 데이터 흐름 |	부모 → 자식 (직계) |	상위 → 하위 (임의 깊이) |	전역 (중앙 집중식) |컴포넌트 간 자유로운 통신 (전역 이벤트) |
| 적합한 상황 |	간단한 부모-자식 통신	| prop drilling 방지, 플러그인/서비스 주입 | 대규모 앱의 전역 상태 관리 |	(Vue 3에서 권장하지 않음) |
| 복잡도 | 매우 낮음 | 중간 (설계에 따라 다름) | 높음 (설정 및 보일러플레이트 코드 필요) | 중간 (로직 분산) |
| 반응성 | 기본 반응형 |	ref/reactive 사용 시 반응형 |	기본 반응형 (엄격한 규칙) |	비반응형 |
| 추적/디버깅 |	명확하고 용이함 |	어려움 (데이터 출처 불명확) |	명확하고 용이함 (devtools 지원) |	매우 어려움 (로직 분산) |
| 공식 권장 사항 | 기본 통신 메커니즘 |	고급 플러그인/라이브러리용, 일반 앱에서는 주의 필요 |	대규모 앱의 전역 상태 관리 |	Vue 3에서 사용 지양 |