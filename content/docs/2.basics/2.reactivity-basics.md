---
title: Reactivity Basics
description: Vue의 반응형 시스템의 기본 개념을 알아봅니다.
navigation:
  icon: i-lucide-app-window
---

## Overview
Vue의 반응형 시스템은 데이터와 UI를 자동으로 동기화해주는 핵심 개념으로, 개발자가 효율적으로 동적인 웹 애플리케이션을 구축할 수 있게 합니다. 
Vue에서는 객체의 속성을 추적하여 변경 사항이 발생하면 관련된 DOM을 즉시 업데이트하는 방식으로 동작합니다. 
::note
즉, 개발자가 일일이 DOM을 갱신하지 않아도, 상태(state)가 변경되면 화면이 자동으로 업데이트되는 방식입니다.
::

이 시스템의 근간이 되는 것은 Vue의 핵심 API인 `reactive`와 `ref`입니다. `reactive`는 객체 기반의 상태 관리를 가능하게 하며, 
`ref`는 단일 값이나 원시 데이터 타입의 추적을 위해 사용됩니다. 컴포넌트 내에서 정의된 반응형 데이터는 DOM과 연결되어 있어, 
데이터를 변경하면 화면이 자동으로 갱신됩니다. 이는 Vue가 제공하는 '가상 DOM' 덕분에 가능한 기능으로, 효율성과 성능 면에서 큰 장점을 제공합니다.

핵심적으로 Vue의 반응형 시스템은 관찰자(Watcher), 반응형 데이터 객체, 의존성 추적 등의 요소로 구성됩니다. 
데이터 변경 사항이 감지되면 관련된 관찰자가 실행되어 변경된 값을 바탕으로 DOM을 업데이트하는 구조를 통해, 
별도의 수동 조작 없이 선언적으로 웹 애플리케이션을 개발할 수 있습니다.

## 핵심 개념
1. State (상태)
- 애플리케이션에서 처리 및 관리해야 하는 데이터.
- 예시: count = 0

2. Reactive Binding (반응형 바인딩)
- 상태와 사용자 인터페이스(UI)를 연결하는 방식.
- 예시: {{ count }}와 같이 작성하면 count 값이 변경될 때 자동으로 화면에 반영됨.

3. Automatic Updates (자동 갱신)
- 개발자가 직접 DOM 조작을 위해 document.querySelector() 같은 코드를 작성할 필요가 없음.
- 프레임워크가 상태 변화를 감지하고, 변경이 필요한 부분만 효율적으로 업데이트함.

```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)
const increment = () => count.value++
</script>

<template>
  <button @click="increment">
    Count is: {{ count }}
  </button>
</template>
```
::note
여기서 count 는 반응형 상태(state)로, 버튼을 클릭할 때마다 값이 변경되며 화면이 자동으로 업데이트됩니다.
::

## Vue의 상태 관리
Vue 3에서 반응형 상태를 구현할 때 가장 널리 쓰이는 두 가지 API는 바로 `ref`와 `reactive`입니다.
이 두 API는 각각 고유한 특징과 활용 방법을 가지고 있어, 프로젝트의 요구 사항에 맞게 선택해 사용할 수 있습니다.

### 1. ref()
- 단일 값(원시 타입)을 반응형으로 만들 때 사용합니다. (**원시 타입**: `string`, `number`, `boolean` ...)
- 값에 접근하거나 변경하려면 반드시 `.value`를 사용해야 합니다.

```vue
<script setup>
import { ref } from 'vue'

const count = ref(0) // 숫자 값이 반응형 상태가 됨

const increment = () => {
  count.value++ // .value를 통해 값 변경
}
</script>

<template>
  <button @click="increment">
    Count is: {{ count }}
  </button>
</template>
```
::note
ref는 숫자, 문자열, 불리언과 같은 원시 타입 데이터를 반응형으로 관리할 때 가장 적합합니다.
::
### 2. reactive()
- 객체(Object), 배열(Array), Map/Set 등과 같은 복잡한 데이터 구조를 반응형으로 관리할 때 활용됩니다.
- `.value`를 사용하지 않고도 직접 속성에 접근하거나 수정이 가능합니다.

```vue
<script setup>
import { reactive } from 'vue'

const user = reactive({
  name: 'Jin',
  age: 25
})

const growOlder = () => {
  user.age++ // 직접 속성에 접근 가능
}
</script>

<template>
  <div>
    <p>{{ user.name }} ({{ user.age }})</p>
    <button @click="growOlder">Grow Older</button>
  </div>
</template>
```
::note
reactive는 상태가 여러 속성을 가진 객체일 때 유용합니다.
::

## Wrapping & Unwrapping (래핑과 언래핑)

::steps{level="3"}
### Wrapping(래핑)이란?
Wrapping은 일반 JavaScript 값을 반응형 객체로 변환하는 절차를 의미합니다. 
Vue 3는 이를 구현하기 위해 내부적으로 Proxy를 활용하여 값의 변화를 효과적으로 감지할 수 있도록 설계되었습니다.

```vue
<script setup>
import {ref, reactive } from 'vue'

// 원시값을 ref로 래핑
const count = ref(0) // 0이 { value: 0 } 형태로 래핑됨

// 객체를 reactive로 래핑
const user = reactive({ name: 'John', age: 25})
</script>
```
### Unwrapping(언래핑)이란?
Unwrapping은 반응형 객체에서 해당 객체가 감싸고 있는 실제 값을 추출하는 과정입니다. 
Vue는 특정 조건이나 상황에서 이 언래핑 과정을 자동으로 처리합니다.
1. 템플릿에서의 자동 언래핑
템플릿에서는 ref가 자동으로 언래핑됩니다:
```vue
<template>
  <!-- .value 없이 바로 사용 가능 -->
  <div>{{ count }}</div>
  <button @click="count++">증가</button>
</template>

<script setup>
import { ref } from 'vue'
const count = ref(0)
</script>
```

2. reactive 객체 내부에서의 언래핑
reactive 객체의 속성으로 ref를 할당하면 자동으로 언래핑됩니다:
```vue
<script setup>
const count = ref(0)
const state = reactive({
  count // 자동으로 언래핑됨
})

console.log(state.count) // 0 (count.value가 아님)
state.count++ // 정상 작동
</script>
```

::warning
나중에 할당하면 언래핑되지 않습니다:
::
```vue
<script setup>
const count = ref(0)
const state = reactive({})

// 나중에 할당하면 언래핑되지 않음
state.count = count

console.log(state.count) // RefImpl 객체
console.log(state.count.value) // 0
</script>
```

3. 배열과 컬렉션에서는 언래핑되지 않음
```vue
<script setup>
const count = ref(0)
const arr = reactive([count])

console.log(arr[0]) // RefImpl 객체
console.log(arr[0].value) // 0

const map = reactive(new Map([['count', count]]))
console.log(map.get('count')) // RefImpl 객체
console.log(map.get('count').value) // 0
</script>
```

4. reactive의 한계와 ref의 장점
`reactive`는 객체 전체를 교체할 수 없습니다. `reactive`로 만든 상태는 참조를 유지해야 반응성을 유지할 수 있기 때문입니다.
```vue
<script setup>
// reactive는 객체 전체를 교체할 수 없음
let user = reactive({ name: 'John' })
user = { name: 'Jane' } // 반응성 잃음!

// ref는 객체 전체 교체 가능
const user = ref({ name: 'John' })
user.value = { name: 'Jane' } // 반응성 유지
</script>
```
- reactive()는 Proxy로 감싼 **특정 객체**를 추적합니다.
- 그런데 user에 새 객체를 통째로 할당하면, Proxy가 끊겨버려서 Vue가 변화를 추적할 수 없게 됩니다.
- 즉, reactive는 **한 번 감싼 객체**만 추적하지, 변수 자체를 추적하지 않음.

::tip
객체 전체를 교체하는 대신, 속성만 업데이트해야 합니다.
::

::

## Proxy를 통한 반응성 구현

::steps{level="3"}

### Proxy란?
Proxy는 ES6에 도입된 JavaScript 기능으로, 객체의 주요 동작인 속성 읽기, 쓰기, 열거 등을 가로채어 이러한 동작을 사용자 정의 방식으로 재구성할 수 있도록 지원합니다.
```js
// 기본 Proxy 예제
const target = { name: 'John' }

const proxy = new Proxy(target, {
  get(target, property) {
    console.log(`읽기: ${property}`)
    return target[property]
  },
  set(target, property, value) {
    console.log(`쓰기: ${property} = ${value}`)
    target[property] = value
    return true
  }
})

proxy.name // "읽기: name" 출력
proxy.age = 25 // "쓰기: age = 25" 출력
```

### Vue3에서 Proxy 활용
#### reactive의 내부 동작
```js
// Vue3의 reactive 간단한 구현 예제
function createReactive(target) {
  const proxy = new Proxy(target, {
    get(target, key, receiver) {
      // 의존성 추적 (track)
      track(target, key)
      
      const result = Reflect.get(target, key, receiver)
      
      // 중첩 객체도 반응형으로 만들기
      if (typeof result === 'object' && result !== null) {
        return createReactive(result)
      }
      
      return result
    },
    
    set(target, key, value, receiver) {
      const oldValue = target[key]
      const result = Reflect.set(target, key, value, receiver)
      
      // 값이 실제로 변경되었을 때만 트리거
      if (oldValue !== value) {
        // 변경 알림 (trigger)
        trigger(target, key)
      }
      
      return result
    }
  })
  
  return proxy
}
```
#### ref의 내부 동작
ref는 객체를 만들어서 value 속성으로 값을 래핑합니다:
```js
// Vue3의 ref 간단한 구현 예제
function createRef(value) {
  const wrapper = {
    _value: value,
    
    get value() {
      // 의존성 추적
      track(wrapper, 'value')
      return this._value
    },
    
    set value(newValue) {
      const oldValue = this._value
      this._value = newValue
      
      // 변경 알림
      if (oldValue !== newValue) {
        trigger(wrapper, 'value')
      }
    }
  }
  
  return wrapper
}
```
::

## 의존성 추적 시스템
::steps{level="3"}
### Effect (부수효과) 시스템
```js
// 현재 실행 중인 effect를 저장
let activeEffect = null
const effectStack = []

function effect(fn) {
  const effectFn = () => {
    try {
      // effect 스택에 push
      effectStack.push(effectFn)
      activeEffect = effectFn
      
      // 사용자 함수 실행 (여기서 reactive 값들이 읽힘)
      return fn()
    } finally {
      // effect 스택에서 pop
      effectStack.pop()
      activeEffect = effectStack[effectStack.length - 1]
    }
  }
  
  effectFn()
  return effectFn
}
```
### Track (의존성 수집)
```js
// 의존성을 저장하는 전역 맵
const targetMap = new WeakMap()

function track(target, key) {
  if (!activeEffect) return
  
  // target -> key -> effects 구조로 저장
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }
  
  let deps = depsMap.get(key)
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  
  deps.add(activeEffect)
}
```
### Trigger (변경 알림)
```js
function trigger(target, key) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return
  
  const effects = depsMap.get(key)
  if (effects) {
    // 모든 관련 effect들을 실행
    effects.forEach(effect => effect())
  }
}
```

### 실제 동작 과정
```js
// 1. reactive 객체 생성
const state = reactive({ count: 0 })

// 2. effect 생성 (computed, watchEffect 등이 내부적으로 사용)
effect(() => {
  console.log('count:', state.count) // 여기서 track 발생
})

// 3. 값 변경
state.count = 1 // 여기서 trigger 발생 -> effect 재실행
```

상세한 흐름:
1. reactive({ count: 0 })에서 Proxy 생성
2. effect(() => {...}) 실행 시 activeEffect 설정
3. state.count 읽을 때 Proxy의 get 트랩 실행
4. track(state, 'count') 호출로 의존성 수집
5. state.count = 1 할당 시 Proxy의 set 트랩 실행
6. trigger(state, 'count') 호출로 관련 effect들 재실행

### 실제 구현 방식
#### 내부 구조 비교
```js
// ref(0) - 원시값
{
  value: 0,  // 일반 값
  __v_isRef: true
}

// ref({ name: 'John' }) - 객체값
{
  value: Proxy객체,  // reactive로 만든 Proxy
  __v_isRef: true
}

// reactive({ name: 'John' })
Proxy객체  // 바로 Proxy
```
#### 코드로 확인하기
```vue
<script setup>
import { ref, reactive, isProxy } from 'vue'

// 1. ref with 원시값
const count = ref(0)
console.log(count) // { value: 0 }
console.log(isProxy(count)) // false (wrapper 객체는 proxy가 아님)
console.log(isProxy(count.value)) // false (원시값)

// 2. ref with 객체
const user = ref({ name: 'John' })
console.log(user) // { value: Proxy객체 }
console.log(isProxy(user)) // false (wrapper 객체는 proxy가 아님)
console.log(isProxy(user.value)) // true (내부 객체는 proxy)

// 3. reactive
const state = reactive({ name: 'John' })
console.log(isProxy(state)) // true (바로 proxy)
</script>
```

### 메모리 관점에서의 차이
```js
// ref - 래퍼 객체 + (필요시 Proxy)
const refData = ref({ name: 'John' })
// 구조: RefWrapper -> Proxy -> 실제 객체

// reactive - 바로 Proxy
const reactiveData = reactive({ name: 'John' })
// 구조: Proxy -> 실제 객체
```
::note
- ref: value로 래핑하는 방식 (+ 객체인 경우 내부에서 reactive 사용)
- reactive: 직접 Proxy로 반응성 구현
::
::

## 베스트 프랙티스
### 1. 올바른 반응성 API 선택
```js
// ✅ 좋은 예
// 원시값은 ref 사용
const count = ref(0)
const message = ref('')
const isLoading = ref(false)

// 객체는 reactive 사용
const user = reactive({
  name: '',
  email: '',
  age: 0
})
// API 응답이나 null 가능한 객체는 ref 사용
const apiData = ref(null)
```
### 2. 구조 분해 할당 시 주의사항
```js
// ❌ 나쁜 예 - 반응성 손실
const { count, message } = reactive({ count: 0, message: 'hello' })

// ✅ 좋은 예 - toRefs 사용
const state = reactive({ count: 0, message: 'hello' })
const { count, message } = toRefs(state)

// ✅ 좋은 예 - 개별 ref 사용
const count = ref(0)
const message = ref('hello')
```
### 3. 디버깅 도구 활용
```js
import { isRef, isReactive, toRaw } from 'vue'

const data = ref({ name: 'John' })

console.log(isRef(data)) // true
console.log(isReactive(data.value)) // true
console.log(toRaw(data.value)) // 원본 객체 반환
```
### 4. 성능 최적화 팁
```js
// ✅ 큰 객체의 일부만 반응형으로 만들기
const bigData = {
  // 많은 데이터...
  importantValue: 0
}

// 전체를 reactive로 만들지 말고
const importantValue = ref(bigData.importantValue)

// ✅ shallowRef/shallowReactive 활용
import { shallowRef, shallowReactive } from 'vue'

// 깊은 반응성이 필요 없는 경우
const shallowData = shallowRef(largeObject)
const shallowState = shallowReactive(largeObject)
```
### 5. 일반적인 실수 방지
```js
// ❌ 나쁜 예 - reactive 객체 전체 교체
let state = reactive({ count: 0 })
state = { count: 1 } // 반응성 잃음!

// ✅ 좋은 예 - ref 사용하거나 속성별 업데이트
const state = ref({ count: 0 })
state.value = { count: 1 } // 반응성 유지

// 또는
const state = reactive({ count: 0 })
Object.assign(state, { count: 1 }) // 반응성 유지
```
Vue3의 반응성 시스템을 깊이 있게 다룬 종합적인 가이드입니다. 
제공된 개념들을 정확히 이해하고 이를 적절히 활용하면, 더욱 효율적이며 안정적인 Vue 애플리케이션을 개발할 수 있습니다.