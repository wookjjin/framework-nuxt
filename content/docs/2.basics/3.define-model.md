---
title: DefineModel
description: Vue 3.5에서 새롭게 선보인 defineModel에 대해 알아보려고 합니다. 
navigation:
  icon: i-lucide-arrow-left-right
---

## defineModel이란?
`defineModel`은 Vue 3의 Composition API에서 활용되는 컴파일러 매크로로, 컴포넌트이 양방향 데이터 바인딩을 표준화하기 위한 syntactic sugar 입니다. 이 함수는 `props`와 `emit`의 조합을 추상화하여, 컴포넌트 간 데이터 동기화 로직을 자동화합니다.

::note
컴포넌트 간 양방향 데이터 바인딩을 간결하고 직관적으로 구현할 수 있게 해주는 핵심 기능으로, 기존 Vue 컴포넌트 통신 방식의 복잡성을 해소하고 개발자 경험을 크게 향상시키는 데 중점을 두고 있습니다.
::

### 1. defineModel의 기본 문법 및 사용법
`defineModel()` 함수는 `v-model`에 의해 바인딩되는 값에 대한 반응형 `ref`를 반환합니다. 이 `ref`는 일반적인 `ref`와 마찬가지로 `.value`를 통해 접근하고 변경할 수 있지만, 부모 값과 로컬 값 사이의 양방향 바인딩으로 작동한다는 특징이 있습니다.
```vue
<!-- ChildComponent.vue -->
<script setup lang="ts">
import { defineModel } from 'vue'

const modelValue = defineModel() // 'modelValue' prop과 'update:modelValue' 이벤트에 자동 연결
</script>

<template>
  <input v-model="modelValue" /> <!-- 로컬 ref를 직접 v-model에 바인딩 -->
</template>
```
이 자식 컴포넌트를 부모 컴포넌트에서 사용할 때는 다음과 같이 `v-model` 디렉티브를 사용합니다.
```vue
<!-- ParentComponent.vue -->
<script setup lang="ts">
import { ref } from 'vue';
import ChildComponent from './ChildComponent.vue';

const message = ref('Hello, defineModel!');
</script>

<template>
  <ChildComponent v-model="message" />
  <p>현재 메시지: {{ message }}</p>
</template>
```
위 예시에서 `ChildComponent`내부의 `modelValue`가 변경되면, `ParentComponent`의 `message`도 자동으로 업데이트됩니다. `defineModel`은 컴파일러 매크로로서, `modelValue` prop과 `update:modelValue` 이벤트, 그리고 이 모든 것을 연결하는 로직을 컴파일 시점에 자동으로 생성합니다.

### 2. 명명된 `v-model`는 다중 바인딩
`v-model`은 인수를 받아 여러 개의 양방향 바인딩을 지원할 수 있습니다. `defineModel()`은 첫 번째 인수로 문자열을 받아 명명된 모델을 정의할 수 있도록 지원합니다.

```vue
<!-- MyDualInput.vue -->
<script setup lang="ts">
import { defineModel } from 'vue';

const firstName = defineModel('firstName'); // v-model:firstName에 연결
const lastName = defineModel('lastName');   // v-model:lastName에 연결
</script>

<template>
  <label>First Name: <input v-model="firstName" /></label><br />
  <label>Last Name: <input v-model="lastName" /></label>
</template>
```
부모 컴포넌트에서는 다음과 같이 여러 개의 `v-model`을 바인딩할 수 있습니다.
```vue
<!-- ParentComponent.vue -->
<script setup lang="ts">
import { reactive } from 'vue';
import MyDualInput from './MyDualInput.vue';

const user = reactive({ firstName: 'John', lastName: 'Doe' });
</script>

<template>
  <MyDualInput v-model:firstName="user.firstName" v-model:lastName="user.lastName" />
  <p>User: {{ user.firstName }} {{ user.lastName }}</p>
</template>
```
### 3. 주요 옵션 및 타입 정의
`defineModel`은 `props`와 유사하게 객체 형태의 두 번째 인자를 통해 다양한 옵션을 설정할 수 있습니다.
- `required`: 모델이 필수로 제공되어야 하는지 여부를 지정합니다.
- `default`: 모델의 기본값을 설정합니다. 객체나 배열과 같은 참조형 타입의 경우 팩토리 함수를 사용해야 합니다.
- `type`: 모델의 데이터 타입을 지정합니다.
- `local`: `local: true` 옵션을 사용하면 `defineModel`이 부모로부터 전달받는 `prop` 없이 내부적으로만 사용되는 `ref`를 생성합니다. 이는 `emit`을 발생하지 않고 컴포넌트 내부에서만 값을 관리할 때 유용합니다.
```ts
const modelValue = defineModel<string>({ required: true }); // 필수 문자열 모델
const count = defineModel<number>('count', { default: 0 }); // 기본값 0을 갖는 숫자 모델
const localData = defineModel('localData', { local: true }); // 로컬 전용 모델
```
TypeScript와 함께 사용할 경우, 제네릭(`<>`)을 통해 모델의 타입을 명시적으로 지정할 수 있어 타입 안전성을 높일 수 있습니다.

### 4. `v-model` 모디파이어 처리
`v-model`은 `.trin`, `.number`, `.lazy`와 같은 내장 모디파이어를 제공하며, 사용자 정의 모디아피어도 지원합니다. `defineModel`은 반환값을 구조 분해하여 모델 값과 함께 `modifiers` 객체를 얻을 수 있습니다.

```vue
<!-- MyInput.vue -->
<script setup lang="ts">
import { defineModel } from 'vue';

const = defineModel({
  set(value) { // set 옵션을 사용하여 모디파이어에 따라 값 변형
    if (modifiers.capitalize) {
      return value.charAt(0).toUpperCase() + value.slice(1);
    }
    return value;
  }
});
</script>

<template>
  <input v-model="modelValue" />
</template>
```
부모 컴포넌트에서는 `v-model.capitalize="myText"`와 같이 사용자 정의 모디파이어를 사용할 수 있습니다. `modifiers` 객체는 해당 모디파이어가 사용되었는지 여부를 `boolean` 값으로 포함합니다. (예: `{ capitalize: true }`)

## defineModel과 기존 컴포넌트 통신 방식 비교
`defineModel`의 도입은 Vue.js에서 컴포넌트 간 데이터 통신 방식에 중대한 변화를 가져왔습니다. `props`, `emit`, 그리고 `v-model`의 전통적인 사용 방식과 비교할 때 그 차이점이 두드러집니다.

### 1. props와 emit의 조합 (기존 방식)
defineModel 도입 이전 버전에서는 부모-자식 컴포넌트 간 양방향 데이터 바인딩을 구현하려면 다음 단계가 필요했습니다.

1. 데이터 하향 전달: `defineProps`를 사용하여 부모 컴포넌트에서 전달되는 `modelValue` porp을 선언합니다.
2. 이벤트 상향 전달: 자식 컴포넌트의 값이 변경될 때 `defineEmits`로 정의된 `update:modelValue` 이벤트를 `emit` 함수를 통해 부모 컴포넌트에 발생시킵니다.

```vue
<script setup lang="ts">
const props = defineProps<{
  modelValue: string
}>()

const emit = defineEmits(['update:modelValue'])
function onInput(event: Event) {
  emit('update:modelValue', (e.target as HTMLInputElement).value)
}
</script>

<template>
  <input :value="modelValue" @input="onInput" />
</template>
```
부모 컴포넌트에서는 `:modelValue`를 통해 prop을 전달하고 `@update:modelValue`를 통해 이벤트를 수신하여 값을 업데이트했습니다. 이 방식은 명확하고 직관적이지만, 보일러플레이트 코드가 많고, 여러 개의 `v-model` 바인딩을 관리할 때 복잡성이 증가했습니다.

### 2. defineModel을 활용한 양방향 바인딩 (새로운 방식)
`defineModel`은 위에서 설명한 `props`와 `emit`의 수동적인 조합을 컴파일러 매크로 수준에서 자동화합니다.

- 단일 선언: `defineModel()` 호출 한 번으로 `modelValue` prop 선언과 `update:modelValue` 이벤트 발생 로직이 자동으로 처리됩니다.
- 반응형 `ref`: `defineModel`이 반환하는 `ref`는 부모 컴포넌트의 값과 직접 동기화되며, 이 `ref`를 자식 컴포넌트 내에서 변경하면 자동으로 `emit` 이벤트가 발생하여 부모의 값을 업데이트합니다.

```vue
<script setup lang="ts">
const modelValue = defineModel<string>({default: ''})
</script>

<template>
  <input v-model="modelValue" />
</template>
```
이 새로운 접근 방식은 코드의 간결성, 가독성, 유지보수성을 크게 향상시킵니다. 개발자는 더 이상 `prop`이름과 `emit` 이벤트 이름을 여러 번 반복하거나 수동으로 이벤트를 처리할 필요가 없습니다.

| 특징 | props + emit (기존 방식) |	defineModel (새로운 방식)
|--------|---------|------------|
| 코드 복잡성	| ​보일러플레이트 코드 많음, props 및 emits 명시적 선언 필요 | ​코드 간결화, props 및 emits 자동 처리 |
| 데이터 흐름	| props로 하향, emit으로 상향 수동 관리	| ​반응형 ref를 통한 자동 양방향 동기화 |
| 유지보수성 | ​복잡한 컴포넌트에서 데이터 추적 및 디버깅 어려움 | ​코드 가독성 및 유지보수성 향상 |
| 다중 바인딩	| ​각 prop 및 emit에 대해 명시적 이름 지정 필요 | 첫 번째 인수로 문자열을 전달하여 간단하게 지원 |
| 모디파이어 | props.modelModifiers를 통해 수동 처리 | ​반환된 modifiers 객체를 통해 선언적으로 처리 |

## defineModel의 활용 사례 및 베스트 프랙티스
### 1. 재사용 가능한 UI 컴포넌트 개발
디자인 시스템이나 컴포넌트 라이브러리를 구축할 때 `defineModel`은 명확한 계약을 시행하고 오류를 줄이는 데 도움을 주어, 다양한 프로젝트에서 컴포넌트를 쉽게 채택하고 유지보수할 수 있게 합니다. 예를 들어, 일반적인 입력 필드, 체크박스, 슬아이더, 날짜 선택기와 같은 사용자 정의 폼 컨트롤에 `defineModel`을 적용하여 양방향 바인딩을 쉽게 구현할 수 있습니다.
```vue
<!-- BaseSwitch.vue -->
<script setup lang="ts">
const checked = defineModel('checked', { default: false })
</script>

<template>
  <label>
    <input type="checkbox" v-model="checked" />
    <span>{{ checked ? 'On' : 'Off' }}</span>
  </label>
</template>
```
부모 컴포넌트에서는 v-model:checked를 통해 이 스위치 컴포넌트를 사용할 수 있습니다.

### 2. 복잡한 폼 입력 및 유효성 검사
이메일 입력 필드와 같은 복잡한 폼 요소는 `defineModel`의 다중 바인딩 기능을 활용하기 좋은 예시입니다.
- 이메일 입력 필드 예시: 부모 컴포넌트에서 이메일 값과 유효성 검사 결과를 각각 `v-model:email` 및 `v-model:emailChk`로 바인딩하고, 자식 컴포넌트에서 `defineModel('email')` 및 `defineModel('emailChk)`로 이를 받아서 처리할 수 있습니다. 이로써 부모-자식 간의 실시간 동기화가 효율적으로 이루어집니다.
```vue
<!-- InputEmail.vue -->
<script setup lang="ts">
const email = defineModel<string>('email');
const emailChk = defineModel<boolean>('emailChk', { default: false });
defineProps<{ placeholder?: string; validChkBox?: boolean }>();
</script>

<template>
  <input type="email" v-model="email" :placeholder="placeholder" />
  <p v-if="!emailChk && validChkBox" class="err-msg">이메일 형식이 올바르지 않습니다.</p>
</template>
```
이러한 접근 방식은 감시가 필요한 상턔(예: `emial`, `emailChk`)와 헌 번만 전달되는 데이터(`placeholder`)를 명확하게 구분하여 코드 가독성을 높입니다.

### 3. 모달 및 상태 제어 컴포넌트
모달의 `isShowModal`과 같은 가시성 상태를 제어할 떄 `defineModel`을 사용하면 편리합니다. 기존에는 `emit`을 통해 부모에게 닫기 요청을 보내야 했지만, `defineModel`을 사용하면 자식 컴포넌트에서 직접 `isModalOpen.value = false`와 같이 값을 변경하여 부모의 상태를 업데이트할 수 있습니다.
```vue
<!-- MyModal.vue -->
<script setup lang="ts">
const isModalOpen = defineModel<boolean>('isModalOpen', { default: false });
const modalData = defineModel<any>('modalData', { default: () => ({ title: '', content: '' }) });

function closeModal() {
  isModalOpen.value = false;
}
</script>

<template>
  <div v-if="isModalOpen" class="modal">
    <h2>{{ modalData.title }}</h2>
    <input v-model="modalData.content" />
    <button @click="closeModal">닫기</button>
  </div>
</template>
```

### 4. defineSlots와의 시너지 효과
`defineModel`은 `defineSlots` 매크로와 함께 사용될 때 강력한 시너지를 발휘하여, 매우 유연하면서도 명시적으로 정의된 컴포넌트를 생성할 수 있습니다. 예를 들어, `defineModel`로 값을 관리하고, `defineSlots`로 레이블이나 유효성 검사 메시지의 사용자 정의 렌더링을 허용하는 복합 입력 컴포넌트를 만들 수 있습니다.
```vue
<!-- MyComplexInput.vue -->
<script setup lang="ts">
defineProps<{ labelText?: string, type?: string, error?: string }>()
defineSlots<{
  label?: () => any,
  error?: (props: { message: string }) => any
}>()

const model = defineModel<string>()
</script>

<template>
  <div class="form-group">
    <label v-if="$slots.label"><slot name="label"></slot></label>
    <label v-else>{{ labelText }}</label>
    <input :type="type" v-model="model" />
    <div class="error-message" v-if="error">
      <slot name="error" :message="error">{{ error }}</slot>
    </div>
  </div>
</template>
```
이러한 조합은 컴포넌트의 API를 더욱 명확하게 하고, 자동 완성 및 타입 검사에 대한 도구 지원을 향상시킵니다.

### 5. 베스트 프랙티스
- Vue 3.4 이상 환경에서 활용: `defineModel`은 Vue 3.4부터 안정화되었으므로, 최신 버전의 Vue를 사용하는 프로젝트에서 적극적으로 활용하는 것이 권장됩니다.
- 단일 및 다중 `v-model` 바인딩에 우선 적용: ​간단한 양방향 바인딩 또는 여러 개의 `v-model` 바인딩이 필요한 커스텀 컴포넌트에 `defineModel`을 우선적으로 사용하여 코드의 간결성을 확보합니다.
- 옵션 활용: `required`, `default`, `type` 등의 옵션을 적극 활용하여 모델의 유효성과 안정성을 높입니다. ​특히 객체 기본값 설정 시에는 팩토리 함수(`default: () => ({})`)를 사용하는 것이 중요합니다.
- `v-model` 모디파이어 지원: = `defineModel()` 패턴을 사용하여 사용자 정의 모디파이어를 깔끔하게 처리하고, `set` 옵션을 통해 값 변환 로직을 구현합니다.
- IME 입력(한국어, 일본어, 중국어) 처리 시 주의: `v-model`은 IME 입력 시 한계가 있으므로, 공식 문서에서 권장하는 `v-bind:value`와 `v-on:input`을 직접 연결하는 방식을 고려해야 합니다.
- 복잡한 데이터 흐름 시 신중한 사용: `defineModel`은 대부분의 경우에 편리하지만, 매우 복잡한 데이터 흐름이나 미묘한 디버깅이 필요한 경우에는 기존의 `defineProps`와 `defineEmits`를 명시적으로 사용하는 것이 더 명확하고 제어하기 쉬울 수 있습니다.

## defineModel의 한계 및 잠재적 문제점
`defineModel`은 Vue.js 개발의 생산성을 크게 향상시키지만, 몇 가지 한계점과 잠재적 문제점도 존재합니다.

### 1. 기본값 및 동기화 문제
`defineModel`에 `default` 값을 설정하고 부모 컴포넌트가 해당 `prop`에 어떤 값도 제공하지 않으면 부모와 자식 컴포넌트 간의 동기화 문제가 발생할 수 있습니다. 예를 들어, 자식 컴포넌트의 `defineModel({ default: 'Hello' })`는 초기값을 `hello`로 갖지만, 부모 컴포넌트에서 `v-model="message"`(`message`가 `undefined`인 경우)로 바인딩하면 부모의 `message`는 `undefined`로 남아 자식과 부모의 값이 불일치하게 됩니다.

### 2. 참조형 데이터 (객체/배열)의 변경 감지
`defineModel`로 바인딩된 객체나 배열의 내부 속성을 직접 변경하는 경우(`model.value.property = 'newVal'), `emit` 이벤트가 발생하지 않아 부모 컴포넌트의 데이터가 업데이트되지 않을 수 있습니다. 이는 Vue의 반응성 시스템이 `ref` 자체의 `.value` 할당에만 반응하여 `emit`을 트리거하기 때문입니다.

- **해결책**: 객체나 배열의 내부를 변경할 때는 항상 새로운 객체/배열을 할당하여 `defineModel`이 반환한 `ref`를 완전히 교체해야 합니다.
```js
// 잘못된 예시: emit이 발생하지 않을 수 있음
model.value.content = '새로운 내용'

// 올바른 예시: 새로운 객체를 할당하여 emit을 트리거
model.value = { ...model.value, content: '새로운 내용' }
```
또한, `defineModel`로 선언된 배열에 `push()`와 같은 배열 변경 메서드를 사용하는 경우에도 값이 트리거되지 않는 문제가 보고되었습니다. 이는 `defineModel`이 기본적으로 참조 변경에만 반응하기 때문에 발생하는 것으로 보입니다.

### 3. IMDE 입력 (한국어, 일본어, 중국어) 한계
Vue의 `v-model`은 한국어, 일본어, 중국어와 같은 IME(Input Method Editor) 입력 방식에 대한 한계점을 가지고 있습니다. 한 글자 입력이 끝나야 텍스트 값이 동기화되는 문제가 발생하며, 이로 인해 공식 문서에서는 IME 입력을 다룰 때 `v-bind:value`와 `v-on:input`을 직접 연결하여 사용하는 것을 권장하고 있습니다. `defineModel`도 결국 `v-model`을 추상화한 것이므로 이 한계는 여전히 존재할 수 있습니다.

### 4. 숨겨진 `prop` 생성 및 이름 충돌
`defineModel`은 `v-model` 모디파이어를 처리하기 위해 내부적으로 `modelModifiers`와 같은 숨겨진 `prop`을 생성합니다. 기본 `modelValue` 모델의 경우 `modelModifiers`가 생성되고, 명명된 모델(예: `v-model:name`)의 경우 `nameModifiers`와 같은 `prop`이 생성됩니다. 만약 개발자가 자체적으로 `modelModifiers`나 `nameModifiers`와 같은 이름의 `prop`을 정의하면 이름 충돌이 발생할 수 있습니다.
```js
// defineModel로 생성된 모델 (예: name)
const name = defineModel<string>("name");

// 내부적으로 생성되는 숨겨진 prop (잠재적 충돌)
// nameModifiers: { type: Object, default: () => ({}) }
```
이는 `defineModel`의 내부 동작을 명확히 인지하고, `Modifier`로 끝나는 `prop`이름을 피하는 것이 좋습니다.

> `defineModel()`는 `v-model`과의 연동을 목적으로 내부적으로 `modelValue`(또는 지정된 모델명)와 이에 해당하는 `Modifiers` prop을 자동으로 생성한다. 이런 작업 덕분에 개발자는 데이터를 쉽게 바인딩할 수 있지만, 이를 통해 특정 이름(`modelModifiers`, `titleModifiers` 등)의 prop을 직접 정의하게 되면 Vue가 자동으로 생성한 prop과 충돌하여 의도한 대로 작동하지 않을 수 있다.

### 5. 디버깅의 복잡성
`defineModel`은 보일러플레이트를 줄여주지만, 내부적으로 `props`와 `emits`를 추상화하므로 복잡한 시나리오에서 데이터 흐름을 추적하고 디버깅하는 것이 어려울 수 있습니다. 특히 부모 컴포넌트의 특정 조건에 따라 자식의 `emit`을 막아야 하거나, `prop`의 변경을 감지하여 복잡한 로직을 수행해야 할 때는 기존 `watch`와 `props` 조합이 더 명확할 수 있습니다.