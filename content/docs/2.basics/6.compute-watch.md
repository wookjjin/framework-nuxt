---
title: Computed & Watch
description: Vue의 computed와 watch에 대해 이해하고, 이를 활용하여 반응형 데이터의 변화를 처리하거나 계산된 값을 효율적으로 관리하는 방법을 배우게 됩니다.
navigation:
  icon: i-lucide-eye
---

## Overview
computed와 watch는 반응형 데이터 관리에 있어 중요한 도구입니다. 이들은 각각 데이터 변화에 대한 처리와 효율적인 계산값 관리라는 역할을 수행하며, 이를 제대로 활용하면 애플리케이션 성능은 물론 코드의 가독성까지 크게 향상시킬 수 있습니다.

## Computed
computed 속성은 보통 데이터 기반으로 계산된 값을 다룰 때 사용됩니다. 계산식이 복잡하거나 여러 데이터 요소를 결합해 결과를 만들어낼 때 유용하며, 내부적으로 캐싱을 통해 성능을 최적화합니다. 즉, 관련된 데이터가 변경되지 않는 한 computed 값은 처음 계산된 결과를 유지하므로 불필요한 재계산이 발생하지 않습니다. 이런 특성 덕분에 많은 Vue 개발자들이 computed를 선호하게 됩니다.

- **선언형 프로그래밍**: `computed`는 계산해야 하는 목표를 정의하는 선언형 프로그래밍 방식입니다.
- **캐싱 제공**: `computed`는 캐싱을 제공하여, 의존하는 값이 변경되지 않으면 이전에 계산된 값을 재사용합니다. ​이로 인해 상태가 변하지 않더라도 매번 연산 작업이 수행되는 methods에 비해 효율적입니다.
- **반응형 계산 속성**: `computed`는 의존하는 값이 변경되었을 때에만 자동으로 다시 계산됩니다.

### 1. **기본 문법**
```vue
<script setup>
import { ref, computed, watch } from 'vue'

const count = ref(0)

// ✅ computed: count에 의존하여 새로운 값을 계산
const double = computed(() => count.value * 2)
</script>

<template>
  <div>
    <p>Count: {{ count }}</p>
    <p>Double: {{ double }}</p>
    <button @click="count++">증가</button>
  </div>
</template>
```

### 2. **computed를 활용한 숫자 포맷팅**
```vue
<script setup>
import { ref, computed } from 'vue';

const productPrice = ref(1000000); // 실제 숫자 데이터

const formattedPrice = computed({
  get() {
    // 숫자 데이터를 통화 형식 문자열로 변환하여 반환
    return productPrice.value.toLocaleString('ko-KR');
  },
  set(newValue) {
    // 입력된 문자열에서 숫자만 추출하여 실제 숫자 데이터에 할당
    // 콤마(,) 제거 후 숫자로 변환
    const numericValue = parseInt(newValue.replace(/,/g, ''));
    if (!isNaN(numericValue)) { // 유효한 숫자인지 확인
      productPrice.value = numericValue;
    }
  }
});
</script>

<template>
  <div>
    <label for="price-input">가격:</label>
    <input type="text" id="price-input" v-model="formattedPrice" />
    <p>저장된 가격 (숫자): {{ productPrice }}</p>
  </div>
</template>
```
### 3. **Getter와 Setter를 활용한 computed**
```vue
<script setup>
const firstName = ref('John'); ((1))
const lastName = ref('Doe'); ((1))

const fullName = computed({ ((1))
  get() { ((1))
    return `${firstName.value} ${lastName.value}`; ((1))
  },
  set(newValue) { ((1))
    const names = newValue.split(' '); ((1))
    firstName.value = names || ''; ((1))
    lastName.value = names || ''; ((1))
  }
});
</script>
```

### 4. **여러 개의 ref를 하나의 computed로 결합하여 관리**
```vue
<script setup>
import { ref, computed } from 'vue';

const street = ref('테헤란로');
const city = ref('서울');
const zipCode = ref('06130');
const fullAddress = computed({
  get() {
    return `${street.value}, ${city.value}, ${zipCode.value}`;
  },
  set(newValue) {
    // 예시: 콤마로 구분된 문자열을 파싱하여 각 주소 구성요소에 할당
    const parts = newValue.split(',').map(part => part.trim());
    if (parts.length === 3) {
      street.value = parts;
      city.value = parts;
      zipCode.value = parts;
    } else {
      console.warn('잘못된 주소 형식입니다. "도로명, 도시, 우편번호" 형식으로 입력해주세요.');
    }
  }
});
</script>

<template>
  <div>
    <label for="address-input">전체 주소:</label>
    <input type="text" id="address-input" v-model="fullAddress" />
    <p>도로명: {{ street }}</p>
    <p>도시: {{ city }}</p>
    <p>우편번호: {{ zipCode }}</p>
  </div>
</template>
```

## Watch
watch는 반응형 상태(reactive state)의 변화를 감지해서 특정 로직을 실행할 때 사용하는 Vue의 기능입니다.

1. watch 함수의 기본 구조
```vue
<script setup>
import { ref, watch } from 'vue'

const count = ref(0)

// count 값이 변할 때마다 실행됨
watch(count, (newValue, oldValue) => {
  console.log(`count가 ${oldValue} → ${newValue}로 변경됨`)
})
</script>
```

2. 여러 변수 감시하기
```vue
<script setup>
import { ref, watch } from 'vue'

const firstName = ref('철수')
const lastName = ref('김')

watch([firstName, lastName], ([newFirstName, newLastName], [oldFirstName, oldLastName]) => {
  console.log(`이름: ${newFirstName}${newLastName}`)
})
</script>
```

3. Reactive 객체 감시
- 객체 전체 감시
```vue
<script setup>
import { reactive, watch } from 'vue'

const user = reactive({
  name: '홍길동',
  age: 25,
  address: {
    city: '서울'
  }
})

// reactive 객체는 자동으로 deep watch
watch(user, (newValue) => {
  console.log('user 객체가 변경되었습니다.', newValue)
})
</script>
```
- 객체의 특정 속성만 감시
```vue
<script setup>
import { reactive, watch } from 'vue'

const user = reactive({
  name: '홍길동',
  age: 25,
  address: {
    city: '서울'
  }
})

// getter 함수 사용
watch(() => user.name, (newName, oldName) => {
  console.log(`이름이 ${oldName}에서 ${newName}으로 변경`)
})

// 중첩된 속성 감시
watch(() => user.address.city, (newCity) => {
  console.log('도시 변경:', newCity)
})
</script>
```
### Watch 옵션들
1. immediate (즉시 실행)
```vue
<script setup>
const count = ref(0)

watch(count, (newValue) => {
  console.log('count:', newValue)
}, {
  immediate: true  // 컴포넌트 생성 즉시 한 번 실행
})
</script>
```
2. deep (깊은 감시)
```vue
<script setup>
const user = ref({
  profile: {
    name: '김철수',
    hobbies: ['독서', '운동']
  }
})

watch(user, (newValue) => {
  console.log('user의 깊은 곳이 변경됨')
}, {
  deep: true  // 중첩된 속성 변경도 감지
})
</script>
```
::tip
Reactive로 선언된 객체는 자동으로 중첩된 속성까지 감지하여 deep watch를 수행하지만, ref로 선언된 객체는 그런 속성을 자동으로 감지하지 않으므로 deep 옵션 설정이 필요하다.
::
3. flush (실행 타이밍)
```vue
<script setup>
watch(count, (newValue) => {
  // DOM 업데이트 관련 작업
}, {
  flush: 'pre'   // 기본값: DOM 업데이트 전
  // flush: 'post'  // DOM 업데이트 후
  // flush: 'sync'  // 동기적으로 실행 (성능상 비추천)
})
</script>
```
4. onTrack/onTrigger (디버깅용)
```vue
<script setup>
watch(count, (newValue) => {
  console.log(newValue)
}, {
  onTrack(e) {
    console.log('추적됨:', e)
  },
  onTrigger(e) {
    console.log('트리거됨:', e)
  }
})
</script>
```

### Watch의 장단점
| 구분 | 장점 | 단점 |
|------|--------|---------|
| **1. 코드 구조** | - 상태 변화에 따라 **부수 효과**(**사이드 이펙트**)를 분리해 코드 흐름이 명확해짐<br>- 특정 값만 감시할 수 있어 **로직이 집중됨** | - 로직이 분산되어 **흐름을 추적하기 어려움**<br>- watch가 많아지면 실행 위치 파악이 힘들어짐 |
| **2. 유연성** | - `computed`로 처리할 수 없는 **비동기 처리, DOM 조작, 외부 상태 변경**에 대응 가능<br>- `immediate`, `deep`, `flush` 등 옵션으로 세밀한 제어 가능 | - 옵션 설정 실수 시 **불필요한 실행**이나 **무한 루프** 발생 가능<br>- `deep` watch는 성능에 악영향 |
| **3. 반응성 처리** | - **특정 상태의 변경만 감시**할 수 있어 효율적<br>- 복잡한 데이터 중 일부 필드만 추적 가능 | - 객체/배열 감시 시 `deep: true` 필요 → 감시 범위 넓어지고 관리 어려움 |
| **4. 실무 활용성** | - **API 호출, 폼 감시, UI 동기화** 등 실무에서 자주 쓰임<br>- 초기값 처리도 `immediate`로 간단하게 가능 | - `computed`로 처리 가능한 로직을 watch로 작성 시 **유지보수성 저하** |
| **5. 디버깅** | - 값 변경 시점을 명확히 잡아 디버깅하기 쉬움 | - watch가 여러 개면 **실행 순서·타이밍 문제**로 디버깅이 어려움 |


## WatchEffect
콜백 내부에 선언된 데이터에 대한 변화를 감지하고 이에 따라 자동으로 실행되는 함수를 설정하는 데 사용됩니다. 이 API는 데이터와의 의존성을 자동으로 추적하여, 의존하고 있는 데이터가 변경되면 관련 로직을 다시 실행해주는 기능을 가집니다. 특히, 데이터와 함수 간의 관계를 명시적으로 선언하지 않아도 되므로 코드의 간결함과 유지보수성을 높이는 데 유용합니다.
```vue
<script setup>
import { watchEffect } from 'vue'

const count = ref(0)
const doubled = ref(0)

// 내부에서 사용된 반응형 데이터를 자동으로 추적
watchEffect(() => {
  doubled.value = count.value * 2
  console.log(`Count: ${count.value}, Doubled: ${doubled.value}`)
})
<script>
```

::note
내부적으로는 특정 "효과(effect)"를 생성한 뒤, 콜백 실행 과정에서 접근한 반응형 값들을 자동으로 추적(track)하는 방식으로 동작합니다. 이를 통해, computed 속성과 유사하게 의존성을 수집하여 갱신 여부를 판단하고 재실행을 트리거합니다.
::

## WatchEffect vs Watch
**기본 개념 비교**
| 항목 | `watch(source, callback, { immediate: true })` | `watchEffect(callback)` |
|------|-----------------------------------------------|----------------------------|
| 감시 대상 | `source`로 명시적으로 지정해야 함 | 콜백 내부에서 **접근한 모든 반응형 값**을 자동으로 추적 |
| 초기 실행 | `immediate: true` 설정 시 **한 번 즉시 실행** | 기본적으로 **등록 직후 즉시 실행**됨 |
| 용도 | **특정 상태**의 변화를 감시하고, 이전 값과 새 값을 기반으로 로직 실행 | 여러 상태에 의존하는 **반응형 부수 효과(side effect)**를 빠르게 작성할 때 |
| 콜백 인자 | `(newValue, oldValue, onCleanup)` | `(onCleanup)`만 있음 — 값 인자는 없음 |
| 정밀 제어 | 감시 대상을 명확히 설정해서 세밀한 제어 가능 | 내부에서 접근한 값 전부가 자동 추적되기 때문에 제어력이 낮음 |


**실행 타이밍 & 내부 동작**
| 항목 | `watch(immediate)` | `watchEffect` |
|------|---------------------|---------------|
| 초기 실행 | immediate 설정 시 1회 실행 | 기본적으로 즉시 실행 |
| 감시 방식 | 지정한 값만 추적 | 콜백 실행 시 접근한 값 자동 추적 |
| old/new 값 비교 | 가능 | 불가능 |
| 동작 방식 | 명시적 effect 등록 | 자동 의존성 수집 후 effect 등록 |

**성능 관점**
| 항목 | `watch(immediate)` | `watchEffect` |
|------|---------------------|---------------|
| 감시 대상 | 지정된 값만 추적 → ✅ 불필요한 감시 없음 | 콜백 내부에서 읽은 모든 반응형 값 추적 → ⚠️ 범위가 넓어질 수 있음 |
| 실행 횟수 | 감시 대상이 바뀔 때만 | 여러 상태가 섞여 있으면 변경될 때마다 모두 재실행 |
| 디버깅 난이도 | 명시적이라 추적하기 쉬움 | 콜백 내부에서 자동 추적되므로 원인을 찾기 어렵기도 함 |
| 메모리/효율 | 감시 대상이 적고 제어 가능 → 효율적 | 추적 대상이 많아지면 오버헤드 발생 가능 |

